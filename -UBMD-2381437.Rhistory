res <- y - yp
sd <- sqrt(sum(res^2)/length(y))
# estimate for unadjusted R^2
r2 <- 1 - sum(res^2)/sum((y - mean(y))^2)
# log-probability (assumes normal distribution of residuals)
logp <- -log(sd) - 0.5*log(2*pi) - 0.5*(res/sd)^2
L <- sum(logp)
# return
data.frame(
r2 = r2,
loglikelihood = L,
multiplier = par[1],
power = par[2],
sd = sd
)
}
# input parameters
x <- seq(1, 10, l = 101)
alpha <- 5
beta <- -0.4
kappa <- 4
y <- alpha*x^beta*rweibull(length(x), kappa, 1/gamma(1 + 1/kappa))
# fit
ft <- power_weibull_fit(x, y)
ft
# plot
xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power
plot(x, y)
lines(xp, yp, col = "red")
# compare likelihood scores
y2 <- ft$multiplier*x^ft$power
p <- dweibull(y/y2, shape = ft$shape, scale = 1/gamma(1 + 1/ft$shape))
ft$loglikelihood
sum(log(p))
mean(y/y2)
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(length(x), kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(10000, kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(10000, kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(10000, kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(10000, kappa, 1/gamma(1 + 1/kappa)))
mean(rweibull(10000, kappa, 1/gamma(1 + 1/kappa)))
p <- dweibull(y/y2, ft$shape, 1/gamma(1 + 1/ft$shape))
ft$loglikelihood
sum(log(p))
plot(y/y2)
plot(y2/y)
plot(y/y2)
mean(y/y2)
ft$shape
1/gamma(1 + 1/ft$shape)
mean(rweibull(1000, ft$shape, 1/gamma(1 + 1/ft$shape)))
ft$loglikelihood
sum(log(p))
gamma(1 + 1/ft$shape)
log(gamma(1 + 1/ft$shape))
log(gamma(1 + 1/ft$shape))*length(y)
log(gamma(1 + 1/ft$shape))*length(y)^2
log(gamma(1 + 1/ft$shape))
length(y)
ft$loglikelihood + log(gamma(1 + 1/ft$shape))*length(y)
ft$loglikelihood - log(gamma(1 + 1/ft$shape))*length(y)
length(y)^2
ft$loglikelihood
x
y
# do not use any observations with NA values in x and/or y
i <- !(is.na(x) | is.na(y))
x <- x[i]
y <- y[i]
# make guess if needed
if (is.null(guess)) {
guess <- power_weibull_initialguess(x, y)
}
# log-likelihood fit
ft <- stats::optim(
guess,
power_weibull_loglikelihood,
gr = power_weibull_loglikelihood_jacobian,
method = "BFGS",
lx = log(x), ly = log(y), weights = weights,
control = list(fnscale = -1)
)
plot(x, y)
guess = NULL
weights = rep(1, length(x))
# do not use any observations with NA values in x and/or y
i <- !(is.na(x) | is.na(y))
x <- x[i]
y <- y[i]
# make guess if needed
if (is.null(guess)) {
guess <- power_weibull_initialguess(x, y)
}
# log-likelihood fit
ft <- stats::optim(
guess,
power_weibull_loglikelihood,
gr = power_weibull_loglikelihood_jacobian,
method = "BFGS",
lx = log(x), ly = log(y), weights = weights,
control = list(fnscale = -1)
)
ft
ft$par
# return
df <- data.frame(
loglikelihood = ft$value,
multiplier = exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3])),
power = ft$par[2],
shape = exp(ft$par[3])
)
# calculate actual likelihood
rel <- y/(df$multiplier*x^df$power)
plot(rel)
mean(rel)
# calculate actual likelihood
rel <- y/(df$multiplier*x^df$power)
p <- stats::dweibull(rel, shape = df$shape, scale = 1/gamma(1 + 1/df$shape))
p
log(p)
sum(log(p))
# parameters
multiplier = exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3]))
# parameters
multiplier <- exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3]))
power <- ft$par[2]
shape <- exp(ft$par[3])
# likelihood
rel <- y/(df$multiplier*x^df$power)
p <- stats::dweibull(rel, shape = shape, scale = 1/gamma(1 + 1/shape))
loglikelihood <- sum(log(p))
# return
df <- data.frame(
loglikelihood = loglikelihood,
multiplier = multiplier,
power = power,
shape = shape
)
#' plot(x, y)
#' lines(xp, yp, col = "red")
#'
#' # compare likelihood scores
#' y2 <- ft$multiplier*x^ft$power
#' p <- dweibull(y/y2, ft$shape, 1/gamma(1 + 1/ft$shape))
#'
#' ft$loglikelihood
#' sum(log(p))
#'
power_weibull_fit <- function(
x,
y,
weights = rep(1, length(x)),
guess = NULL
) {
# do not use any observations with NA values in x and/or y
i <- !(is.na(x) | is.na(y))
x <- x[i]
y <- y[i]
# make guess if needed
if (is.null(guess)) {
guess <- power_weibull_initialguess(x, y)
}
# log-likelihood fit
ft <- stats::optim(
guess,
power_weibull_loglikelihood,
gr = power_weibull_loglikelihood_jacobian,
method = "BFGS",
lx = log(x), ly = log(y), weights = weights,
control = list(fnscale = -1)
)
# parameters
multiplier <- exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3]))
power <- ft$par[2]
shape <- exp(ft$par[3])
# likelihood
rel <- y/(df$multiplier*x^df$power)
p <- stats::dweibull(rel, shape = shape, scale = 1/gamma(1 + 1/shape))
loglikelihood <- sum(log(p))
# return
df <- data.frame(
loglikelihood = loglikelihood,
multiplier = multiplier,
power = power,
shape = shape
)
}
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_logtransform_fit(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#'
#' plot(x, y)
#' lines(xp, yp)
#'
power_logtransform_fit <- function(
x,
y,
weights = rep(1, length(x))
) {
# log-log fitting
ft <- stats::lm(log(y) ~ log(x), weights = weights)
par <- as.vector(ft$coefficients)
# residuals and variance
logyp <- stats::predict(ft)
res <- log(y) - logyp
sdlog <- sqrt(sum(res^2)/length(y))
# log-probability (assumes normal distribution of residuals)
logp <- -log(sdlog) - 0.5*log(2*pi) - 0.5*(res/sdlog)^2
L <- sum(logp)
# return
data.frame(
r2 = summary(ft)$r.squared,
loglikelihood = L,
multiplier = exp(par[1] + 0.5*sdlog^2),
power = par[2],
sdlog = sdlog
)
}
x <- seq(2, 10, l = 25)
y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
ft <- power_logtransform_fit(x, y)
xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power
plot(x, y)
lines(xp, yp)
yp2 <- ft$multiplier*x^ft$power
mean(y/yp2)
x <- seq(2, 10, l = 25)
y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
ft <- power_logtransform_fit(x, y)
xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power
plot(x, y)
lines(xp, yp)
# test if average of fit OK
yp2 <- ft$multiplier*x^ft$power
mean(y/yp2)
x <- seq(2, 10, l = 25)
y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
ft <- power_logtransform_fit(x, y)
xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power
plot(x, y)
lines(xp, yp)
# test if average of fit OK
yp2 <- ft$multiplier*x^ft$power
mean(y/yp2)
x <- seq(2, 10, l = 25)
y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
ft <- power_logtransform_fit(x, y)
xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power
plot(x, y)
lines(xp, yp)
# test if average of fit OK
yp2 <- ft$multiplier*x^ft$power
mean(y/yp2)
x <- seq(2, 10, l = 25)
y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
ft <- power_logtransform_fit(x, y)
xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power
plot(x, y)
lines(xp, yp)
# test if average of fit OK
yp2 <- ft$multiplier*x^ft$power
mean(y/yp2)
devtools::document()
rm(list = c("power_logtransform_fit", "power_nls_fit", "power_weibull_fit"))
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
#' plot(x, y)
#' lines(xp, yp, col = "red")
#'
#' # compare likelihood scores
#' y2 <- ft$multiplier*x^ft$power
#' p <- dweibull(y/y2, ft$shape, 1/gamma(1 + 1/ft$shape))
#'
#' ft$loglikelihood
#' sum(log(p))
#'
power_weibull_fit <- function(
x,
y,
weights = rep(1, length(x)),
guess = NULL
) {
# do not use any observations with NA values in x and/or y
i <- !(is.na(x) | is.na(y))
x <- x[i]
y <- y[i]
# make guess if needed
if (is.null(guess)) {
guess <- power_weibull_initialguess(x, y)
}
# log-likelihood fit
ft <- stats::optim(
guess,
power_weibull_loglikelihood,
gr = power_weibull_loglikelihood_jacobian,
method = "BFGS",
lx = log(x), ly = log(y), weights = weights,
control = list(fnscale = -1)
)
# parameters
multiplier <- exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3]))
power <- ft$par[2]
shape <- exp(ft$par[3])
# likelihood
rel <- y/(df$multiplier*x^df$power)
p <- stats::dweibull(rel, shape = shape, scale = 1/gamma(1 + 1/shape))
loglikelihood <- sum(weights*log(p))
# return
data.frame(
loglikelihood = loglikelihood,
multiplier = multiplier,
power = power,
shape = shape
)
}
devtools::install()
x <- seq(1, 10, l = 101)
alpha <- 5
beta <- -0.4
kappa <- 4
y <- alpha*x^beta*rweibull(length(x), kappa, 1/gamma(1 + 1/kappa))
# fit
ft <- power_weibull_fit(x, y)
ft
x <- seq(1, 10, l = 101)
alpha <- 5
beta <- -0.4
kappa <- 4
y <- alpha*x^beta*rweibull(length(x), kappa, 1/gamma(1 + 1/kappa))
# do not use any observations with NA values in x and/or y
i <- !(is.na(x) | is.na(y))
x <- x[i]
y <- y[i]
# make guess if needed
if (is.null(guess)) {
guess <- power_weibull_initialguess(x, y)
}
guess <- power_weibull_initialguess(x, y)
# log-likelihood fit
ft <- stats::optim(
guess,
power_weibull_loglikelihood,
gr = power_weibull_loglikelihood_jacobian,
method = "BFGS",
lx = log(x), ly = log(y), weights = weights,
control = list(fnscale = -1)
)
weights = rep(1, length(x))
# log-likelihood fit
ft <- stats::optim(
guess,
power_weibull_loglikelihood,
gr = power_weibull_loglikelihood_jacobian,
method = "BFGS",
lx = log(x),
ly = log(y),
weights = weights,
control = list(fnscale = -1)
)
ft$par
# parameters
multiplier <- exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3]))
power <- ft$par[2]
shape <- exp(ft$par[3])
# likelihood
rel <- y/(multiplier*x^power)
p <- stats::dweibull(rel, shape = shape, scale = 1/gamma(1 + 1/shape))
loglikelihood <- sum(weights*log(p))
# return
data.frame(
loglikelihood = loglikelihood,
multiplier = multiplier,
power = power,
shape = shape
)
#' plot(x, y)
#' lines(xp, yp, col = "red")
#'
#' # compare likelihood scores
#' y2 <- ft$multiplier*x^ft$power
#' p <- dweibull(y/y2, ft$shape, 1/gamma(1 + 1/ft$shape))
#'
#' ft$loglikelihood
#' sum(log(p))
#'
power_weibull_fit <- function(
x,
y,
weights = rep(1, length(x)),
guess = NULL
) {
# do not use any observations with NA values in x and/or y
i <- !(is.na(x) | is.na(y))
x <- x[i]
y <- y[i]
# make guess if needed
if (is.null(guess)) {
guess <- power_weibull_initialguess(x, y)
}
# log-likelihood fit
ft <- stats::optim(
guess,
power_weibull_loglikelihood,
gr = power_weibull_loglikelihood_jacobian,
method = "BFGS",
lx = log(x),
ly = log(y),
weights = weights,
control = list(fnscale = -1)
)
# parameters
multiplier <- exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3]))
power <- ft$par[2]
shape <- exp(ft$par[3])
# likelihood
rel <- y/(multiplier*x^power)
p <- stats::dweibull(rel, shape = shape, scale = 1/gamma(1 + 1/shape))
loglikelihood <- sum(weights*log(p))
# return
data.frame(
loglikelihood = loglikelihood,
multiplier = multiplier,
power = power,
shape = shape
)
}
y <- alpha*x^beta*rweibull(length(x), kappa, 1/gamma(1 + 1/kappa))
# fit
ft <- power_weibull_fit(x, y)
ft
# plot
xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power
plot(x, y)
lines(xp, yp, col = "red")
# compare likelihood scores
y2 <- ft$multiplier*x^ft$power
p <- dweibull(y/y2, ft$shape, 1/gamma(1 + 1/ft$shape))
ft$loglikelihood
sum(log(p))
devtools::install()
#' plot(x, y)
#' lines(xp, yp, col = "red")
#'
#' # compare likelihood scores
#' y2 <- ft$multiplier*x^ft$power
#' p <- dweibull(y/y2, ft$shape, 1/gamma(1 + 1/ft$shape))
#'
#' ft$loglikelihood
#' sum(log(p))
#'
power_weibull_fit <- function(
x,
y,
weights = rep(1, length(x)),
guess = NULL
) {
# do not use any observations with NA values in x and/or y
i <- !(is.na(x) | is.na(y))
x <- x[i]
y <- y[i]
# make guess if needed
if (is.null(guess)) {
guess <- power_weibull_initialguess(x, y)
}
# log-likelihood fit
ft <- stats::optim(
guess,
power_weibull_loglikelihood,
gr = power_weibull_loglikelihood_jacobian,
method = "BFGS",
lx = log(x),
ly = log(y),
weights = weights,
control = list(fnscale = -1)
)
# parameters
multiplier <- exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3]))
power <- ft$par[2]
shape <- exp(ft$par[3])
# likelihood
rel <- y/(multiplier*x^power)
p <- stats::dweibull(rel, shape = shape, scale = 1/gamma(1 + 1/shape))
loglikelihood <- sum(weights*log(p))
# return
data.frame(
loglikelihood = loglikelihood,
multiplier = multiplier,
power = power,
shape = shape
)
}
power_weibull_fit(diameter, tru)
