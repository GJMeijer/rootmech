# Functions for generating nice plots for data+fits
# G. J. Meijer, 08/08/2023


#' GGplot for power-law with Weibull fitting
#'
#' @description
#' Generate a plot, using ggplot, of a power-law fit using weibull
#' probabilities. Will also show the best fit and prediction intervals if
#' values are given as input.
#'
#' @param dr measured x-values (typically, root diameter)
#' @param y measured y-values (e.g. root tensile strength)
#' @param multiplier power-law multiplier for best fit
#' @param power power-law power coefficient for best fit
#' @param shape Weibull shape parameter
#' @param confidence vector with prediction interval significance. For example
#'   `confidence = c(0.5, 0.95)` will show the areas that contain 50% and 95%
#'   of predicted measurements respectively.
#' @param annotations dataframe with labels to annotate, generated by function
#'   `create_annotations()`
#' @param xlab,ylab x and y-axis labels
#' @param xlim,ylim two-element vectors with min and max values for the x and
#'   y-axes. If axis limit can be freely chosen, specify the value of the min
#'   and/or max as `NA`. The function will try to find nice axis limits for all
#'   `NA` values using the function `round_range()`,
#' @param ticks maximum number of ticks on the axis. Used in function
#'   `round_range()`
#' @param n number of (equally spaced) points along the best power-law fit
#' @param dr0 reference diameter for power-law fits
#' @param settings list with default plot settings, as generated by the function
#'   `plot_settings`
#' @return ggplot object
#' @examples
#' # input parameters
#' dr <- seq(2, 9.5, l = 50)
#' multiplier <- 10
#' power <- -0.3
#' shape <- 4
#'
#' # generate some y-data
#' y <- multiplier*dr^power*rweibull(length(dr), shape = shape, scale = 1/gamma(1 + 1/shape))
#'
#' # generate some labels
#' labels <- create_annotations(
#'   c(multiplier, power, shape),
#'   prefix = c("t[r*','*u*','*0]==", "beta[t]==", "kappa[t]=="),
#'   suffix = c("~'MPa'", "", ""),
#'   parse = TRUE
#' )
#'
#' # plot
#' power_weibull_plot(dr, y, multiplier, power, shape, labels = labels)
#'
power_weibull_plot <- function(
    dr,
    y,
    multiplier = NULL,
    power = NULL,
    shape = NULL,
    confidence = c(0.5, 0.95),
    annotations = NULL,
    xlab = expression("Root diameter"~d[r]~"[mm]"),
    ylab = expression("Tensile strength"~t[r*","*u]~"[MPa]"),
    xlim = c(0, NA),
    ylim = c(0, NA),
    ticks = 7,
    n = 101,
    dr0 = 1,
    settings = plot_settings()
) {
  # determine axes
  xlims <- round_range(dr, lim = xlim, ticks = ticks)
  ylims <- round_range(y, lim = ylim, ticks = ticks)
  # initiate plot
  plt <- ggplot2::ggplot() +
    ggplot2::theme_bw() +
    ggplot2::xlab(xlab) +
    ggplot2::ylab(ylab)
  # generate fits
  if (!is.null(multiplier) & !is.null(power)) {
    # generate fit line
    df_fit <- data.frame(dr = seq(min(dr), max(dr), l = n))
    df_fit$y <- multiplier*(df_fit$dr/dr0)^power
    if (!is.null(shape) & length(confidence) >= 1) {
      # generate confidence intervals
      df_c <- data.frame(
        confidence = confidence,
        mlower = stats::qweibull(0.5 - 0.5*confidence, shape = shape, scale = 1/gamma(1 + 1/shape)),
        mupper = stats::qweibull(0.5 + 0.5*confidence, shape = shape, scale = 1/gamma(1 + 1/shape))
      )
      df_conf <- expand.grid.df(df_fit, df_c)
      df_conf$lower <- df_conf$y*df_conf$mlower
      df_conf$upper <- df_conf$y*df_conf$mupper
      # add to plot
      plt <- plt + ggplot2::geom_ribbon(
        data = df_conf,
        ggplot2::aes(x = dr, ymin = lower, ymax = upper, group = as.factor(confidence)),
        fill = settings$fill_fit,
        alpha = settings$alpha_fit/length(confidence),
      )
      # update ranges
      xlims <- round_range(dr, lim = xlim, ticks = ticks)
      ylims <- round_range(c(df_conf$lower, df_conf$upper, y), lim = ylim, ticks = ticks)
    }
  }
  # add points to plot
  plt <- plt + ggplot2::geom_point(
    data = data.frame(x = dr, y = y),
    ggplot2::aes(x = x, y = y),
    color = settings$color_meas,
    shape = settings$shape_meas,
    size = settings$size_meas
  )
  # add fit to plot
  if (!is.null(multiplier) & !is.null(power)) {
    plt <- plt + ggplot2::geom_line(
      data = df_fit,
      ggplot2::aes(x = dr, y = y),
      color = settings$color_fit,
      linetype = settings$linetype_fit,
      linewidth = settings$linewidth_fit
    )
  }
  # add labels to plot
  if (!is.null(annotations)) {
    annotations$xplot <- xlims$lim[1] + diff(xlims$lim)*annotations$x
    annotations$yplot <- ylims$lim[1] + diff(ylims$lim)*annotations$y
    plt <- plt + ggplot2::geom_text(
      data = annotations,
      ggplot2::aes(x = xplot, y = yplot, label = label, hjust = hjust, vjust = vjust),
      parse = annotations$parse[1],
      color = settings$color_ann,
      size = settings$size_ann
    )
  }
  # set axis limits
  plt <- plt +
    ggplot2::scale_x_continuous(breaks = xlims$breaks) +
    ggplot2::scale_y_continuous(breaks = ylims$breaks) +
    ggplot2::coord_cartesian(xlim = xlims$lim, ylim = ylims$lim, expand = FALSE)
  # return plot
  plt
}


#' GGplot for copula fitting
#'
#' @description
#' Generate a plot, using ggplot, of the copula fit between root strain to
#' failure and root tensile strength, both normalised by the power-law fitted
#' predictions.
#'
#' A Gaussian copula is used, and the marginal distributions are both
#' Weibull-distributed with known shape parameter and a mean of 1.
#'
#' Prediction intervals can be generated.
#'
#' @inheritParams power_weibull_plot
#' @param x,y arrays with x and y-observations.
#' @param shape_x,shape_y Weibull shape parameters for parameters `x` and `y`
#' @param rho correlation coefficient for the Gaussian copula
#' @param ellipsoid_axes if `TRUE`, plot the major and minor axis of the
#'   Gaussian prediction ellipsoid
#' @param ellipsoid_axes_linetype array with linetypes for major and minor
#'   axis of the prediction ellipsoid
#' @return ggplot object
#' @examples
#' # input
#' shape_x <- 4
#' shape_y <- 6
#' rho <- -0.4
#'
#' # create random data
#' df <- biomech_random(rep(1, 100), 1, 0, shape_x, 1, 0, shape_y, rho = rho)
#'
#' # annotations
#' labels <- create_annotations(rho, prefix = "rho==", parse = TRUE)
#'
#' # plot
#' copula_gaussian_plot(df$epsru, df$tru, shape_x, shape_y, rho = rho, labels = labels)
#'
copula_gaussian_plot <- function(
    x,
    y,
    shape_x,
    shape_y,
    rho = 0,
    confidence = c(0.5, 0.95),
    annotations = NULL,
    xlab = expression(epsilon[r*","*u]/epsilon[r*","*u*","*fit]),
    ylab = expression(t[r*","*u]/t[r*","*u*","*fit]),
    xlim = c(NA, NA),
    ylim = c(NA, NA),
    ticks = 7,
    ellipsoid_axes = TRUE,
    ellipsoid_axes_linetype = c(1, 2),
    settings = plot_settings()
) {
  # initiate plot
  plt <- ggplot2::ggplot() +
    ggplot2::theme_bw() +
    ggplot2::xlab(xlab) +
    ggplot2::ylab(ylab)
  # generate prediction intervals
  if (!is.null(rho) & length(confidence) >= 1) {
    df_ell <- bivariate_normal_predictioninterval(rho = rho, confidence = confidence)
    df_conf <- bivariate_normal_toweibull(df_ell$x, df_ell$y, shape_x, shape_y)
    df_conf$confidence <- df_ell$confidence
    # add prediction intervals to plot
    plt <- plt + ggplot2::geom_polygon(
      data = df_conf,
      ggplot2::aes(x = x, y = y, group = as.factor(confidence)),
      alpha = settings$alpha_fit/length(confidence),
      fill = settings$fill_fit
    )
    # calculate axes
    if (ellipsoid_axes == TRUE) {
      df_ax <- bivariate_normal_axes(rho = rho, confidence = max(confidence))
      df_axes <- bivariate_normal_toweibull(df_ax$x, df_ax$y, shape_x, shape_y)
      df_axes$axis <- df_ax$axis
      # add axes to plot
      plt <- plt + ggplot2::geom_path(
        data = df_axes,
        ggplot2::aes(x = x, y = y, linetype = as.factor(axis)),
        color = settings$color_fit,
        linewidth = settings$linewidth_fit,
        show.legend = FALSE
      ) +
        ggplot2::scale_linetype_manual(values = ellipsoid_axes_linetype)
    }
    # determine axes limits
    xlims <- round_range(c(x, df_conf$x), lim = xlim, ticks = ticks)
    ylims <- round_range(c(y, df_conf$y), lim = ylim, ticks = ticks)
  } else {
    # determine axes limits
    xlims <- round_range(x, lim = xlim, ticks = ticks)
    ylims <- round_range(y, lim = ylim, ticks = ticks)
  }
  # add points to plot
  plt <- plt + ggplot2::geom_point(
    data = data.frame(x = x, y = y),
    ggplot2::aes(x = x, y = y),
    color = settings$color_meas,
    shape = settings$shape_meas,
    size = settings$size_meas
  )
  # add labels to plot
  if (!is.null(annotations)) {
    annotations$xplot <- xlims$lim[1] + diff(xlims$lim)*annotations$x
    annotations$yplot <- ylims$lim[1] + diff(ylims$lim)*annotations$y
    plt <- plt + ggplot2::geom_text(
      data = annotations,
      ggplot2::aes(x = xplot, y = yplot, label = label, hjust = hjust, vjust = vjust),
      parse = annotations$parse[1],
      color = settings$color_ann,
      size = settings$size_ann
    )
  }
  # change axis limits
  plt <- plt +
    ggplot2::scale_x_continuous(breaks = xlims$breaks) +
    ggplot2::scale_y_continuous(breaks = ylims$breaks) +
    ggplot2::coord_cartesian(xlim = xlims$lim, ylim = ylims$lim, expand = FALSE)
  # return plot
  plt
}


#' Plot observed and fitted cumulative root distributions
#'
#' @description
#' Plot the observed and multisegment power-law fit for the cumulative density
#' distribution of variable `x`.
#'
#' Plots are generated using the ggplot2 package.
#'
#' @inheritParams power_weibull_plot
#' @param x vector with observations
#' @param dfp dataframe with fitting values per segment. For more information,
#'   see documentation in output argument in function `rootcount_fit()`
#' @param n
#' @examples
#' x <- c(
#'   rweibull(25, shape = 4, scale = 1),
#'   rweibull(25, shape = 6, scale = 3),
#'   rweibull(25, shape = 12, scale = 6)
#' )
#'
#' ft <- rootcount_fit(x, 2)
#'
#' rootcount_cumulative_plot(x, ft$par)
rootcount_cumulative_plot <- function(
    x,
    dfp,
    n = 101,
    xlab = expression("Root diameter"~d[r]~"[mm]"),
    ylab = "Cumulative probability density [-]",
    xlim = c(0, NA),
    ylim = c(0, 1),
    ticks = 7,
    settings = plot_settings()
) {
  # cumulative trace - observations
  df1 <- rootcount_cumulative_observations(x)
  # cumulative trace - fit
  df2 <- rootcount_cumulative_fitted(dfp, n = n)
  # axes limits
  xlims <- round_range(c(x, dfp$xmin), lim = xlim, ticks = ticks)
  ylims <- round_range(c(0, 1), lim = ylim, ticks = ticks)
  # plot
  ggplot2::ggplot() +
    ggplot2::theme_bw() +
    ggplot2::geom_path(
      data = df1,
      ggplot2::aes(x = x, y = y),
      color = settings$color_meas,
      linetype = settings$linetype_meas,
      size = settings$linewidth_meas
    ) +
    ggplot2::geom_path(
      data = df2,
      ggplot2::aes(x = x, y = y),
      color = settings$color_fit,
      linetype = settings$linetype_fit,
      size = settings$linewidth_fit
    ) +
    ggplot2::xlab(xlab) +
    ggplot2::ylab(ylab) +
    ggplot2::scale_x_continuous(breaks = xlims$breaks) +
    ggplot2::scale_y_continuous(breaks = ylims$breaks) +
    ggplot2::coord_cartesian(
      xlim = xlims$lim,
      ylim = ylims$lim,
      expand = FALSE
    )
}


#' @examples
#' x <- c(
#'   rweibull(25, shape = 4, scale = 1),
#'   rweibull(25, shape = 6, scale = 3),
#'   rweibull(25, shape = 12, scale = 6)
#' )
#'
#' ft <- rootcount_fit(x, 2)
#'
#' rootcount_density_plot(x, ft$par)
#'
rootcount_density_plot <- function(
    x,
    dfp,
    bins = 30,
    n = 101,
    xlab = expression("Root diameter"~d[r]~"[mm]"),
    ylab = "Probability density [-]",
    xlim = c(0, NA),
    ylim = c(0, NA),
    ticks = 7,
    settings = plot_settings()
) {
  # cut - to get estimation of max density in bar
  ct <- floor((x - min(x))/(max(x) - min(x))*bins) + 1
  ct[ct > bins] <- bins
  tb <- table(ct)
  df1 <- data.frame(x = seq(min(x), max(x), l = bins), n = 0)
  df1$n[as.integer(row.names(tb))] <- as.vector(tb)
  df1$y <- df1$n/length(x)*(max(x) - min(x))
  # fitted density curve
  df2 <- rootcount_density_fitted(dfp, n = n)
  df2 <- data.frame(
    bundle_id = c(1, df2$bundle_id, max(df2$bundle_id)),
    x = c(df2$x[1], df2$x, utils::tail(df2$x, 1)),
    y = c(0, df2$y, 0)
  )
  # axes limits
  xlims <- round_range(c(df1$x, df2$x), lim = xlim, ticks = ticks)
  ylims <- round_range(c(df1$y, df2$y), lim = ylim, ticks = ticks)
  # plot
  ggplot2::ggplot() +
    ggplot2::theme_bw() +
    #geom_histogram(
    #  aes(x = x, y = ..density..),
    #  bins = bins,
    #  color = settings$color_meas,
    #  fill = settings$fill_meas,
    #  alpha = settings$alpha_meas
    #) +
    ggplot2::geom_col(
      data = df1,
      ggplot2::aes(x = x, y = y)
    ) +
    ggplot2::geom_path(
      data = df2,
      ggplot2::aes(x = x, y = y),
      color = settings$color_fit,
      linetype = settings$linetype_fit,
      size = settings$linewidth_fit
    ) +
    ggplot2::xlab(xlab) +
    ggplot2::ylab(ylab) +
    ggplot2::scale_x_continuous(breaks = xlims$breaks) +
    ggplot2::scale_y_continuous(breaks = ylims$breaks) +
    ggplot2::coord_cartesian(
      xlim = xlims$lim,
      ylim = ylims$lim,
      expand = FALSE
    )
}


#' Add a label in the corner of an existing ggplot
#'
#' @description
#' Add a text label an existing ggplot object. For example. use to annotate
#' a subplot indicator to an exsiting plot
#'
#' @param plt ggplot object
#' @param label vector with character strings to add
#' @param location two-part vector indicating the relative location in the
#'   plot for placing labels. Follows same logic as legend placement in ggplot.
#' @param justification two-part vector indicating the horizontal and
#'   vertical justification of the labels. Follwos the same logic as legend
#'   justification in ggplot
#' @param label_spacing if `label` consists of multiple elements, the relative
#'   `y`-spacing between each element
#' @param size plot size of text
#' @param color plot color of text
#' @param parse if `TRUE`, labels are parsed when plotted
#' @return ggplot object with added annotation
#' @export
#'
annotate_label <- function(
    plt,
    label,
    location = c(0.02, 0.98),
    justification = c(0, 1),
    label_spacing = 0.10,
    size = 3,
    color = "black",
    parse = FALSE
) {
  # get current ggplot limits
  xlim <- plt$coordinates$limits$x
  ylim <- plt$coordinates$limits$y
  # plus or minus
  pm <- 1 - 2*justification
  # get coordinates for plotting
  x <- xlim[1] + location[1]*diff(xlim)
  y <- ylim[1] + (location[2] + pm[2]*(label_spacing*(seq(length(label)) - 1)))*diff(ylim)
  # add annotation and return
  plt + ggplot2::annotate(
    "text",
    x = x,
    y = y,
    label = label,
    hjust = justification[1],
    vjust = justification[2],
    color = color,
    size = size,
    parse = parse
  )
}


#' Determine rounded plot axis limits
#'
#' @description
#' Determine plot axis limits based on input values, preferred tick step sizes
#' and a maximum number of ticks
#'
#' @md
#' @param x values on axis that should be within the plot range
#' @param lim two-parameter vector with fixed axis limits. If `NA`, an axis
#'   limit can be freely chosen
#' @param step array with possible step sizes. These values are relative to
#'   the order of magnitude of the difference in input `x`, i.e. relative to
#'   `10^floor(log10(max(x) - min(x)))`
#' @param ticks the maximum number of ticks that is acceptable
#' @return a list with field:
#'
#'   * `lim`: two-parameter vector with min and max limit of the plot range
#'   * `breaks`: vector with plot breakpoints
#'
#' @examples
#' # data
#' x <- 10*rnorm(100)
#'
#' # basic range
#' z <- round_range(x)
#' plot(x, seq(length(x)), xlim = z$lim, xaxs = "i", xaxt = "n")
#' axis(side = 1, at = z$breaks)
#'
#' # fix the lower bound
#' z <- round_range(x, lim = c(-100, NA))
#' plot(x, seq(length(x)), xlim = z$lim, xaxs = "i", xaxt = "n")
#' axis(side = 1, at = z$breaks)
#'
round_range <- function(
    x,
    lim = c(NA, NA),
    step = c(0.1, 0.2, 0.5, 1, 2, 5),
    ticks = 7
) {
  # get all limits
  lims <- c(
    min(min(x), lim[1], na.rm = TRUE),
    max(max(x), lim[2], na.rm = TRUE)
  )
  # order of magnitude of difference
  oom <- floor(log10(diff(lims)))
  # round scaled upper and lower values using potential step sizes (step)
  z0 <- floor((lims[1]/10^oom)/step)*step
  z1 <- ceiling((lims[2]/10^oom)/step)*step
  # calculate number of ticks with distance <step> required for each option
  ntick <- ceiling((z1 - z0)/step)
  ntick[ntick > ticks] <- 0
  # pick option that has the most ticks but number still smaller than <n>
  i <- which.max(ntick)
  # set range
  range <- c(z0[i], z1[i])*10^oom
  # substitute fixed values
  range[!is.na(lim)] <- lim[!is.na(lim)]
  # return range and ticks
  list(
    lim = range,
    breaks = seq(range[1], range[2], step[i]*10^oom)
  )
}


#' Round a double to a number of significant digits and convert to character
#'
#' @description
#' Round a number to a number of significant digits and convert to character
#' string. Always returns `digits` number of significant digits, also when
#' there are trailing zeros
#'
#' @param x numeric value to convert to character string
#' @param digits number of significant digits
#' @return character string
#' @export
#' @examples
#' numeric2character(pi, digits = 4)
#' numeric2character(sqrt(5)/100000, digits = 3)
#'
numeric2character <- function(x, digits = 3) {
  gsub(
    "\\.$", "",
    formatC(
      signif(x, digits = digits),
      digits = digits,
      format = "fg",
      flag = "#"
    )
  )
}


#' Create annotation labels for plotting
#'
#' @description
#' Creates character strings for annotating a plot. Combines a prefix, a
#' numeric value (will be converted to a string using the `numeric2character()`
#' function) and a character suffix.
#'
#' @param values array with values to be rounded
#' @param prefix,suffix arrays with character prefix and suffixes
#' @param parse if `TRUE`, the combined character string is assumed as an
#'   parseable expression
#' @param sep seperator to put between prefix, value and suffixes
#' @param digits number of significant digits to use when rounding values
#' @param x,y relative location of label in the plot (0 <= x,y <= 1)
#' @param hjust,vjust horizontal and vertical justification of labels in the
#'   plot
#' @return dataframe with fields for labels (`label`), relative position in
#'   plot (`x`, `y`), text justification (`hjust`, `vjust`) and whether the
#'   labels should be parsed or not (`parse`)
#' @examples
#' create_annotations(
#'   c(0.23, -0.1),
#'   prefix = c("a=", ""),
#'   suffix = c(" mm", " N"),
#'   parse = FALSE,
#'   digits = 4
#' )
#'
create_annotations <- function(
    values,
    prefix = NULL,
    suffix = NULL,
    parse = TRUE,
    sep = "",
    digits = 3,
    x = 0.98,
    y = 0.98 - seq(0, length(values) - 1)*0.10,
    hjust = 1,
    vjust = 1
) {
  # values to string
  val_chr <- numeric2character(values, digits = digits)
  # generate
  if (parse == TRUE) {
    labels <- paste(prefix, "'", val_chr, "'", suffix, sep = sep)
  } else {
    labels <- paste(prefix, val_chr, suffix, sep = sep)
  }
  # return dataframe
  data.frame(
    label = labels,
    x = x,
    y = y,
    hjust = hjust,
    vjust = vjust,
    parse = parse
  )
}


#' List with general plot settings
#'
#' @description
#' Generate a list with 'standard' plot settings.
#'
#' @param color_meas color for measurements
#' @param fill_meas fill color for measurements polygons
#' @param linewidth_meas linewidth for measurements lines
#' @param linetype_meas linetype for measurements lines
#' @param size_meas point size for measurements
#' @param shape_meas shape for measurement points
#' @param alpha_fit transparancy values for measurements polygons
#' @param color_fit color for fitting lines
#' @param fill_fit fill color for fitting polygons
#' @param linewidth_fit linewidth for fitting lines
#' @param linetype_fit linetype for fitting lines
#' @param shape_fit shape for fitting points
#' @param alpha_fit transparancy values for fitting polygons
#' @param color_ann color for text annotations
#' @param size_ann font size for text annotations
#' @return list with fields (input parameter names) and values
#' @examples
#' plot_settings()
#'
plot_settings <- function(
    color_meas = "#377EB8",
    fill_meas = color_meas,
    size_meas = 1,
    linewidth_meas = 0.5,
    linetype_meas = 1,
    shape_meas = 20,
    alpha_meas = 0.25,
    color_fit = "#E41A1C",
    fill_fit = color_fit,
    linewidth_fit = 0.5,
    linetype_fit = 1,
    shape_fit = 20,
    alpha_fit = 0.25,
    color_ann = color_fit,
    size_ann = 3
) {
  list(
    color_meas = color_meas,
    fill_meas = fill_meas,
    size_meas = size_meas,
    linewidth_meas = linewidth_meas,
    linetype_meas = linetype_meas,
    shape_meas = shape_meas,
    alpha_meas = alpha_meas,
    color_fit = color_fit,
    fill_fit = fill_fit,
    linewidth_fit = linewidth_fit,
    linetype_fit = linetype_fit,
    shape_fit = shape_fit,
    alpha_fit = alpha_fit,
    color_ann = color_ann,
    size_ann = size_ann
  )
}

