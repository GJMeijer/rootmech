#' Fit power-law function using linear fitting on the log-log-transform
#'
#' @description
#' Fit a power law function between `x` and `y` in the form y = a*x^b.
#'
#' The fit is generated using the `stats::lm()` linear least-squares
#' regression function in R, between the log-transformed x and y data.
#'
#' The power-law function describing the 'mean' data is given by
#'
#' y = exp(0.5*a*sdlog^2)*x^b
#'
#' where a is the intercept, b is the gradient of the linear fit on the
#' log-log-transform. sdlog is the standard deviation of the residuals of the
#' log-log fit. The correction exp(0.5*sdlog^2) is required since the mean of
#' the log(y) is not equal to the mean of y.
#'
#' @inheritParams power_weibull_fit
#' @return dataframe with the unadjusted R^2 value of best fit (field `r2`),
#'   the multiplier (`multiplier`) and power coefficient (`power`), the
#'   standard deviation of the log-transformed residuals (`sdlog`) and the
#'   loglikelihood score (`loglikelihood`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_logtransform_fit(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#'
#' plot(x, y)
#' lines(xp, yp)
#'
#' # test if average of fit OK
#' yp2 <- ft$multiplier*x^ft$power
#' mean(y/yp2)
power_logtransform_fit <- function(
    x,
    y,
    weights = rep(1, length(x))
) {
  # log-log fitting
  ft <- stats::lm(log(y) ~ log(x), weights = weights)
  par <- as.vector(ft$coefficients)
  # residuals and variance
  logyp <- stats::predict(ft)
  res <- log(y) - logyp
  sdlog <- sqrt(sum(weights*res^2)/sum(weights))
  # log-probability (assumes normal distribution of residuals)
  logp <- -log(sdlog) - 0.5*log(2*pi) - 0.5*(res/sdlog)^2
  L <- sum(weights*logp)
  # return
  data.frame(
    r2 = summary(ft)$r.squared,
    loglikelihood = L,
    multiplier = exp(par[1] + 0.5*sdlog^2),
    power = par[2],
    sdlog = sdlog
  )
}


#' Generate prediction interval for log-transformed power-law fit
#'
#' @description
#' Generate a prediction interval with a certain amount of confidence it
#' contains a random new observation. Fit is generated by the function
#' `power_logtransform_fit()`.
#'
#' @inheritParams power_nls_predictioninterval
#' @param sdlog standard deviation of the log-transformed fit residuals
#' @return dataframe with values for x (`x`), the mean value for y (`y`), and
#'   the lower and upper bounds of the confidence interval (`lower`, `upper`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 250)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_logtransform_fit(x, y)
#' df <- power_logtransform_predictioninterval(
#'   min(x), max(x), ft$multiplier, ft$power, ft$sdlog)
#'
#' plot(x, y, ylim = c(0, max(y)))
#' lines(df$x, df$mean, col = "red")
#' lines(df$x, df$lower, col = "blue")
#' lines(df$x, df$upper, col = "blue")
#'
power_logtransform_predictioninterval <- function(
    xmin,
    xmax,
    multiplier,
    power,
    sdlog,
    confidence = 0.95,
    n = 101
) {
  # generate or x-values range
  df <- data.frame(x = seq(xmin, xmax, l = n))
  # generate fit
  df$mean <- multiplier*df$x^power
  # distance - log-transformed space
  m <- stats::qlnorm(
    0.5 + c(-0.5, 0.5)*confidence,
    meanlog = -0.5*sdlog^2,
    sdlog = sdlog
  )
  # lower and upper prediction interval
  df$lower <- m[1]*df$mean
  df$upper <- m[2]*df$mean
  # return dataframe
  df
}
