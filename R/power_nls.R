#' Fit power-law function using least-squares regression
#'
#' @description
#' Fit a power law function between `x` and `y` in the form y = a*x^b.
#'
#' The fit is generated using the `stats::nlm()` non-linear least-squares
#' regression function in R.
#'
#' @inheritParams power_weibull_fit
#' @param guess vector with initial guess for the power-law multiplier and
#'   power coefficient. If not defined, a guess is made best on linear
#'   fitting of the log-transformed `x` and `y` data.
#' @return dataframe with the unadjusted R^2 value of best fit (field `r2`),
#'   the multiplier (`multiplier`) and power coefficient (`power`), the
#'   standard deviation of the residuals (`sd`) and the loglikelihood score
#'   (`loglikelihood`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_nls_fit(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#'
#' plot(x, y)
#' lines(xp, yp)
#'
power_nls_fit <- function(
    x,
    y,
    weights = rep(1, length(x)),
    guess = NULL
) {
  # initial guess, based on log-log fitting
  if (is.null(guess)) {
    ft0 <- stats::lm(log(y) ~ log(x), weights = weights)
    guess <- as.vector(c(exp(ft0$coefficients[1]), ft0$coefficients[2]))
  }
  # non-linear least squares fitting
  ft1 <- stats::nls(
    y ~ a*x^b,
    start = list(a = guess[1], b = guess[2])
  )
  par <- as.vector(coef(ft1))
  # residuals and variance
  yp <- stats::predict(ft1)
  res <- y - yp
  sd <- sd(res)
  # estimate for unadjusted R^2
  r2 <- 1 - sum(res^2)/sum((y - mean(y))^2)
  # log-probability (assumes normal distribution of residuals)
  logp <- -log(sd) - 0.5*log(2*pi) - 0.5*(res/sd)^2
  L <- sum(logp)
  # return
  data.frame(
    r2 = r2,
    loglikelihood = L,
    multiplier = par[1],
    power = par[2],
    sd = sd
  )
}


#' Generate prediction interval for nonlinear least squares power-law fit
#'
#' @description
#' Generate a prediction interval with a certain amount of confidence it
#' contains a random new observation. Fit is generated by the function
#' `power_nls_fit()`.
#'
#' @param xmin,xmax min and max values of the dependent variable. Confidence
#'   interval is plotted between these values only
#' @param multiplier fitted power-law multiplier
#' @param power fitted power-law power coefficient
#' @param sd standard deviation of the fit residuals
#' @param confidence confidence level for the prediction interval, centred
#'   around the mean. For example `confidence = 0.95` plots a confidence
#'   interval with two tails of 2.5\% on either side
#' @param n number of equally spaced points to use on x-interval
#' @return dataframe with values for x (`x`), the mean value for y (`y`), and
#'   the lower and upper bounds of the confidence interval (`lower`, `upper`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 250)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_nls_fit(x, y)
#' df <- power_nls_predictioninterval(
#'   min(x), max(x), ft$multiplier, ft$power, ft$sd)
#'
#' plot(x, y, ylim = c(0, max(y)))
#' lines(df$x, df$mean, col = "red")
#' lines(df$x, df$lower, col = "blue")
#' lines(df$x, df$upper, col = "blue")
#'
power_nls_predictioninterval <- function(
    xmin,
    xmax,
    multiplier,
    power,
    sd,
    confidence = 0.95,
    n = 101
) {
  # generate or x-values range
  df <- data.frame(x = seq(xmin, xmax, l = n))
  # generate fit
  df$mean <- multiplier*df$x^power
  # distance
  m <- qnorm(0.5 + 0.5*confidence, mean = 0, sd = sd)
  # lower and upper prediction interval
  df$lower <- df$mean - m
  df$upper <- df$mean + m
  # return dataframe
  df
}


