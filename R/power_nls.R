#' Fit power-law function assuming normally distributed residuals
#'
#' @description
#' Fit a power law function between `x` and `y` in the form y = a*x^b.
#'
#' The fit is generated by depending on the choice of `method`. Either, the
#' log-likelihood probem is solved using a bracketing root finding algorithm
#' (`method = "uniroot"`) or gradient-descent root finding algorithm
#' (`method = "newton"`). If `method == "nls"`, the default R function
#' `stats::nls()` is used.
#'
#' @inheritParams power_weibull_fit
#' @param power_range default range in which the power coefficient is expected
#'   to lie. This range is used in the `uniroot` root search algorithm. If the
#'   value does not lie in this interval, it will be automatically extended in
#'   the `uniroot()` function.
#' @return dataframe with the multiplier (`multiplier`) and power coefficient
#'   (`power`), the standard deviation of the residuals (`sd`) and the
#'   loglikelihood score (`loglikelihood`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_normal_fit(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#'
#' plot(x, y)
#' lines(xp, yp, col = "red")
#'
power_normal_fit <- function(
    x,
    y,
    weights = rep(1, length(x)),
    power_range = c(-2, 1),
    method = "uniroot",
    sd_power = 0
) {
  if ((sd_power != 0) & !(method %in% c("uniroot", "newton"))) {
    stop("standard deviation power coefficient can only be fixed when using methods `uniroot` or `newton`")
  }
  if (method == "uniroot") {
    ## UNITOOT METHOD - BISECTION ROOT FINDING
    # find shape parameter using root solve
    power <- stats::uniroot(
      function(b) {
        sum(weights*x^(2*b - 2*sd_power))*sum(weights*y*x^(b - 2*sd_power)*log(x)) -
          sum(weights*y*x^(b - 2*sd_power))*sum(weights*x^(2*b - 2*sd_power)*log(x))
      },
      interval = power_range,
      extendInt = "downX"
    )$root
    # get multiplier
    multiplier <- sum(weights*y*x^(power - 2*sd_power))/sum(weights*x^(2*power - 2*sd_power))
  } else if (method == "newton") {
    ## NEWTON ROOT SOLVING METHOD
    # initial guess for power-law - from log-log linear fit
    ft <- lm(log(y) ~ log(x), weights = weights)
    power0 <- as.numeric(ft$coefficients[2])
    # find power, using gradient descent root solving techniques
    power <- rootSolve::multiroot(
      function(b, x, y, weights, sd_power = 0) {
        sum(weights*x^(2*b - 2*sd_power))*sum(weights*y*x^(b - 2*sd_power)*log(x)) -
          sum(weights*y*x^(b - 2*sd_power))*sum(weights*x^(2*b - 2*sd_power)*log(x))
      },
      start = power0,
      jacfunc = function(b, x, y, weights) {
        sum(weights*x^(2*b - 2*sd_power)*log(x))*sum(weights*y*x^(b - 2*sd_power)*log(x)) +
          sum(weights*x^(2*b - 2*sd_power))*sum(weights*y*x^(b - 2*sd_power)*log(x)^2) -
          2*sum(weights*y*x^(b - 2*sd_power))*sum(weights*x^(2*b - 2*sd_power)*log(x)^2)
      },
      x = x,
      y = y,
      weights = weights,
      sd_power = sd_power
    )$root
    # get multiplier
    multiplier <- sum(weights*y*x^(power - 2*sd_power))/sum(weights*x^(2*power - 2*sd_power))
  } else if (method == "nls") {
    ## USE R NLS FUNCTION
    # initial guess, based on log-log fitting
    ft0 <- stats::lm(log(y) ~ log(x), weights = weights)
    guess <- as.vector(c(exp(ft0$coefficients[1]), ft0$coefficients[2]))
    # non-linear least squares fitting
    ft1 <- stats::nls(
      y ~ a*x^b,
      start = list(a = guess[1], b = guess[2]),
      weights = weights
    )
    par <- as.vector(stats::coef(ft1))
    multiplier <- as.numeric(stats::coef(ft1)[1])
    power <- as.numeric(stats::coef(ft1)[2])
  } else {
    stop("Method not recognised")
  }
  # get standard deviation
  mu <- multiplier*x^power
  co <- power_normal_sdpower_coef(power, sd_power, x, y, weights = weights)
  sd_multiplier <- sqrt((co[3]*co[7] - co[5]^2)/(co[1]*co[7]))
  sd <- sd_multiplier*x^sd_power
  # likelihood
  logpi <- -log(sd) - 0.5*log(2*pi) - 0.5*((y - mu)/sd)^2
  # return dataframe
  data.frame(
    loglikelihood = sum(weights*logpi),
    multiplier = multiplier,
    power = power,
    sd = sd_multiplier
  )
}


#' Generate prediction interval for nonlinear least squares power-law fit
#'
#' @description
#' Generate a prediction interval with a certain amount of confidence it
#' contains a random new observation. Fit is generated by the function
#' `power_normal_fit()`.
#'
#' @param xmin,xmax min and max values of the dependent variable. Confidence
#'   interval is plotted between these values only
#' @param multiplier fitted power-law multiplier
#' @param power fitted power-law power coefficient
#' @param sd standard deviation of the fit residuals
#' @param confidence confidence level for the prediction interval, centred
#'   around the mean. For example `confidence = 0.95` plots a confidence
#'   interval with two tails of 2.5\% on either side
#' @param n number of equally spaced points to use on x-interval
#' @return dataframe with values for x (`x`), the mean value for y (`y`), and
#'   the lower and upper bounds of the confidence interval (`lower`, `upper`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 250)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_normal_fit(x, y)
#' df <- power_normal_predictioninterval(
#'   min(x), max(x), ft$multiplier, ft$power, ft$sd)
#'
#' plot(x, y, ylim = c(0, max(y)))
#' lines(df$x, df$mean, col = "red")
#' lines(df$x, df$lower, col = "blue")
#' lines(df$x, df$upper, col = "blue")
#'
power_normal_predictioninterval <- function(
    xmin,
    xmax,
    multiplier,
    power,
    sd,
    confidence = 0.95,
    n = 101
) {
  # generate or x-values range
  df <- data.frame(x = seq(xmin, xmax, l = n))
  # generate fit
  df$mean <- multiplier*df$x^power
  # distance
  m <- stats::qnorm(0.5 + 0.5*confidence, mean = 0, sd = sd)
  # lower and upper prediction interval
  df$lower <- df$mean - m
  df$upper <- df$mean + m
  # return dataframe
  df
}


#' Fit power-law curve with normal residuals and power-law standard deviation
#'
#' @description
#' Fit a power-law curve to a set of `x`, `y` data. The residuals are assumed
#' to be normally distributed with a mean of zero and a standard deviation that
#' itself varies with `x` according to a seperate power-law.
#'
#' The problem is solved by maximising the loglikelihood score. In detail, the
#' problem is solved by root solving the derivatives of the loglikelihood
#' function. This results in only having to solve for two parameters
#' (power coeficient of fit, and that one of the standard deviation). The other
#' parameters can be expressed in terms of these two power coefficients.
#'
#' The root problem is solved using the `rootSolve::multiroot()` function, with
#' a explicitly defined jacobian.
#'
#' @inheritParams power_normal_fit
#' @return dataframe with the multiplier (`multiplier`) and power coefficient
#'   (`power`) of the fit, the multiplier (`sd_multiplier`) and
#'   power coefficient (`sd_power`) of the standard deviation of the residuals, the standard deviation of the residuals (`sd`) and the
#'   and the (weighted) loglikelihood score (`loglikelihood`)
#' @export
#' @examples
#' beta <- -0.6
#' delta <- -0.4
#' x <- seq(2, 10, l = 100)
#' y <- abs(50*x^beta + 20*rnorm(length(x))*x^delta)
#' y <- abs(y)
#' ft <- power_normal_sdpower_fit(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#' range <- 2*ft$sd_multiplier*xp^ft$sd_power
#'
#' plot(x, y)
#' lines(xp, yp, col = "red")
#' lines(xp, yp - range, col = "red")
#' lines(xp, yp + range, col = "red")
power_normal_sdpower_fit <- function(
    x,
    y,
    weights = rep(1, length(x))
) {
  # generate intial guess
  par0 <- power_normal_sdpower_initialguess(x, y, weights = weights)
  # fit
  sol <- rootSolve::multiroot(
    power_normal_sdpower_root,
    start = par0,
    jacfunc = power_normal_sdpower_root_jacobian,
    x = x,
    y = y,
    weights = weights
  )
  # calculate coefficients
  co <- power_normal_sdpower_coef(sol$root[1], sol$root[2], x, y, weights = weights)
  multiplier <- co[5]/co[7]
  power <- sol$root[1]
  sd_multiplier <- sqrt((co[3]*co[7] - co[5]^2)/(co[1]*co[7]))
  sd_power = sol$root[2]
  # calculate likelihood
  mu <- multiplier*x^power
  sigma <- sd_multiplier*x^sd_power
  logpi <- -log(sigma) - 0.5*log(2*pi) - 0.5*((y - mu)/sigma)^2
  # dataframe with results
  data.frame(
    loglikelihood = sum(weights*logpi),
    multiplier = multiplier,
    power = sol$root[1],
    sd_multiplier = sd_multiplier,
    sd_power = sol$root[2]
  )
}


#' Generate initial guess for `power_normal_sdpower_fit()` function
#'
#' @description
#' Generate an initial guess for the fit power coefficient (beta) and the
#' standard derivation of residuals power coefficient (delta). This is used
#' as a starting point for a two-dimensional gradient-descent root-finding
#' algorithm.
#'
#' Beta is estimated using a linear fit on the log-log transformed data.
#' Delta is then found using root solving (`stats::uniroot()` bracketing
#' algorithm), assuming the residuals (calculated using the initial log-log
#' transformed fit) are normally distributed with a mean of zero and a
#' standard deviation following a power law.
#'
#' @inheritParams power_normal_sdpower_fit
#' @return two-vector array with initial guesses for both power coefficients
#'
power_normal_sdpower_initialguess <- function(
    x,
    y,
    weights = rep(1, length(x))
) {
  # beta, from intial linear fit
  ft1 <- lm(log(y) ~ log(x), weights = weights)
  alpha <- exp(as.numeric(ft1$coefficients[1]))
  beta0 <- as.numeric(ft1$coefficients[2])
  # fit linear line though residuals
  res <- y - alpha*x^beta
  delta0 <- uniroot(
    function(d, x, res) {
      -sum(weights*log(x)) +
        sum(weights)*sum(weights*res^2*x^(-2*d)*log(x))/
        sum(weights*res^2*x^(-2*d))
    },
    beta0 + c(-1, 1),
    extendInt = "downX",
    x = x,
    res = res
  )$root
  # return
  c(beta0, delta0)
}




#' Intermediate coefficients used in function `power_normal_sdpower_fit()`
#'
#' @description
#' Defines eight intermediate variables that are used in the root solving
#' procedure used in the function `power_normal_sdpower_fit()` in order
#' to obtain fitting coefficients.
#'
#' @inheritParams power_normal_sdpower_fit
#' @param beta power coefficient of the fit
#' @param delta power coefficient of the standard deviation of residuals
#' @return vector with intermediate coefficients
#'
power_normal_sdpower_coef <- function(beta, delta, x, y, weights = rep(1, length(x))) {
  c(
    sum(weights),
    sum(weights*log(x)),
    sum(weights*y^2*x^(-2*delta)),
    sum(weights*y^2*x^(-2*delta)*log(x)),
    sum(weights*y*x^(beta - 2*delta)),
    sum(weights*y*x^(beta - 2*delta)*log(x)),
    sum(weights*x^(2*beta - 2*delta)),
    sum(weights*x^(2*beta - 2*delta)*log(x))
  )
}


#' Jacobian of `power_normal_sdpower_coef()`
#'
#' @description
#' Return the derivative of intermediate coefficients (determined using the
#' function `power_normal_sdpower_coef()`) with respect to input arguments
#' `beta` and `delta`.
#'
#' @inheritParams power_normal_sdpower_coef
#' @return a 8*2 matrix (rows = coefficients, columns = derivatives, i.e. beta
#'   and delta)
#' @examples
#' # Test derivative - compare to simple numerical solution
#' beta <- -0.6
#' delta <- 0.2
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-beta * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' w <- runif(length(x))
#'
#' eps <- 1e-6
#' co <- power_normal_sdpower_coef(beta, delta, x, y, weights = w)
#' co1 <- power_normal_sdpower_coef(beta + eps, delta, x, y, weights = w)
#' co2 <- power_normal_sdpower_coef(beta, delta + eps, x, y, weights = w)
#' (cbind(co1, co2) - co)/eps
#' power_normal_sdpower_coef_jacobian(beta, delta, x, y, weights = w)
power_normal_sdpower_coef_jacobian <- function(beta, delta, x, y, weights = rep(1, length(x))) {
  cbind(
    c(
      0,
      0,
      0,
      0,
      sum(weights*y*x^(beta - 2*delta)*log(x)),
      sum(weights*y*x^(beta - 2*delta)*log(x)^2),
      2*sum(weights*x^(2*beta - 2*delta)*log(x)),
      2*sum(weights*x^(2*beta - 2*delta)*log(x)^2)
    ),
    c(
      0,
      0,
      -2*sum(weights*y^2*x^(-2*delta)*log(x)),
      -2*sum(weights*y^2*x^(-2*delta)*log(x)^2),
      -2*sum(weights*y*x^(beta - 2*delta)*log(x)),
      -2*sum(weights*y*x^(beta - 2*delta)*log(x)^2),
      -2*sum(weights*x^(2*beta - 2*delta)*log(x)),
      -2*sum(weights*x^(2*beta - 2*delta)*log(x)^2)
    )
  )
}


#' Root function that is to be solved in `power_normal_sdpower_fit()`
#'
#' @description
#' Functions that need to be root-solved with respect to input arguments
#' `par`, as part of function `power_normal_sdpower_fit()`.
#'
#' @inheritParams power_normal_sdpower_fit
#' @param par two-parameter vector with values of beta and delta (power of
#'   power law curve, power of standard deviation of residuals)
#' @return two-parameter vector that must be equal to zero at the correct
#'   values of `par`
#'
power_normal_sdpower_root <- function(par, x, y, weights = rep(1, length(x))) {
  co <- power_normal_sdpower_coef(par[1], par[2], x, y, weights = weights)
  r1 <- co[5]/co[7] - co[6]/co[8]
  r2 <- (co[3]*co[7] - co[5]^2)/(co[1]*co[7]) - (co[4]*co[8] - co[6]^2)/(co[2]*co[8])
  c(r1, r2)
}

#' Jacobian of function `power_normal_sdpower_root()`
#'
#' @description
#' Returns the derivative of the function `power_normal_sdpower_root()` with
#' respect to the input arguments in `par`.
#'
#' @inheritParams power_normal_sdpower_root
#' @return a two by two vector with the jacobian.
#' @examples
#' # Test derivative - compare to simple numerical solution
#' par <- c(-0.6, -0.35)
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-beta * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' w <- runif(length(x))
#'
#' eps <- 1e-6
#' bd <- power_normal_sdpower_root(par, x, y, weights = w)
#' bd1 <- power_normal_sdpower_root(par + c(eps, 0), x, y, weights = w)
#' bd2 <- power_normal_sdpower_root(par + c(0, eps), x, y, weights = w)
#' (cbind(bd1, bd2) - bd)/eps
#' power_normal_sdpower_root_jacobian(par, x, y, weights = w)
#'
power_normal_sdpower_root_jacobian <- function(par, x, y, weights = rep(1, length(x))) {
  # coefficients
  co <- power_normal_sdpower_coef(par[1], par[2], x, y, weights = weights)
  dco_dpar <- power_normal_sdpower_coef_jacobian(par[1], par[2], x, y, weights = weights)
  # derivatives of root with respect to coefficients
  dr_dco <- rbind(
    c(
      0,
      0,
      0,
      0,
      1/co[7],
      -1/co[8],
      -co[5]/co[7]^2,
      co[6]/co[8]^2
    ),
    c(
      -(co[3]*co[7] - co[5]^2)/(co[1]^2*co[7]),
      (co[4]*co[8] - co[6]^2)/(co[2]^2*co[8]),
      1/co[1],
      -1/co[2],
      -2*co[5]/(co[1]*co[7]),
      2*co[6]/(co[2]*co[8]),
      co[3]/(co[1]*co[7]) - (co[3]*co[7] - co[5]^2)/(co[1]*co[7]^2),
      -co[4]/(co[2]*co[8]) + (co[4]*co[8] - co[6]^2)/(co[2]*co[8]^2)
    )
  )
  # derivatives of roots withr respect to <par>
  dr_dco %*% dco_dpar
}

