#' Fit power-law function using least-squares regression
#'
#' @description
#' Fit a power law function between `x` and `y` in the form y = a*x^b.
#'
#' The fit is generated by solving the log-likelihood problem, using a scalar
#' root search (R function `stats::uniroot()` in order to obtain the power
#' coefficient.
#'
#' @inheritParams power_weibull_fit
#' @param power_range default range in which the power coefficient is expected
#'   to lie. This range is used in the root search algorithm. If the value
#'   does not lie in this interval, it will be automatically extended in the
#'   `uniroot()` function.
#' @return dataframe with the multiplier (`multiplier`) and power coefficient
#'   (`power`), the standard deviation of the residuals (`sd`) and the
#'   loglikelihood score (`loglikelihood`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_nls_fit(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#'
#' plot(x, y)
#' lines(xp, yp)
#'
power_nls_fit <- function(
    x,
    y,
    weights = rep(1, length(x)),
    power_range = c(-2, 1)
) {
  # find shape parameter using root solve
  power <- stats::uniroot(
    function(b) {
      sum(weights*x^(2*b))*sum(weights*y*x^b*log(x)) -
        sum(weights*y*x^b)*sum(weights*x^(2*b)*log(x))
    },
    interval = power_range,
    extendInt = "downX"
  )$root
  # get multiplier
  multiplier <- sum(weights*y*x^power)/sum(weights*x^(2*power))
  # get standard deviation
  mu <- multiplier*x^power
  sd <- sqrt(sum(weights*(y - mu)^2)/sum(weights))
  # likelihood
  logp <- -log(sd) - 0.5*log(2*pi) - 0.5*((y - mu)/sd)^2
  # return dataframe
  data.frame(
    loglikelihood = sum(weights*logp),
    multiplier = multiplier,
    power = power,
    sd = sd
  )
}


#' Fit power-law function using least-squares regression
#'
#' @description
#' Fit a power law function between `x` and `y` in the form y = a*x^b.
#'
#' The fit is generated using the `stats::nls()` non-linear least-squares
#' regression function in R.
#'
#' @inheritParams power_weibull_fit
#' @param guess vector with initial guess for the power-law multiplier and
#'   power coefficient. If not defined, a guess is made best on linear
#'   fitting of the log-transformed `x` and `y` data.
#' @return dataframe with the unadjusted R^2 value of best fit (field `r2`),
#'   the multiplier (`multiplier`) and power coefficient (`power`), the
#'   standard deviation of the residuals (`sd`) and the loglikelihood score
#'   (`loglikelihood`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_nls_fit_nlm(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#'
#' plot(x, y)
#' lines(xp, yp)
#'
power_nls_fit_nls <- function(
    x,
    y,
    weights = rep(1, length(x)),
    guess = NULL
) {
  # initial guess, based on log-log fitting
  if (is.null(guess)) {
    ft0 <- stats::lm(log(y) ~ log(x), weights = weights)
    guess <- as.vector(c(exp(ft0$coefficients[1]), ft0$coefficients[2]))
  }
  # non-linear least squares fitting
  ft1 <- stats::nls(
    y ~ a*x^b,
    start = list(a = guess[1], b = guess[2])
  )
  par <- as.vector(stats::coef(ft1))
  # residuals and variance
  yp <- stats::predict(ft1)
  res <- y - yp
  sd <- sqrt(sum(weights*res^2)/sum(weights))
  # estimate for unadjusted R^2
  r2 <- 1 - sum(res^2)/sum((y - mean(y))^2)
  # log-probability (assumes normal distribution of residuals)
  logp <- -log(sd) - 0.5*log(2*pi) - 0.5*(res/sd)^2
  # return
  data.frame(
    loglikelihood = sum(weights*logp),
    multiplier = par[1],
    power = par[2],
    sd = sd
  )
}


#' Generate prediction interval for nonlinear least squares power-law fit
#'
#' @description
#' Generate a prediction interval with a certain amount of confidence it
#' contains a random new observation. Fit is generated by the function
#' `power_nls_fit()`.
#'
#' @param xmin,xmax min and max values of the dependent variable. Confidence
#'   interval is plotted between these values only
#' @param multiplier fitted power-law multiplier
#' @param power fitted power-law power coefficient
#' @param sd standard deviation of the fit residuals
#' @param confidence confidence level for the prediction interval, centred
#'   around the mean. For example `confidence = 0.95` plots a confidence
#'   interval with two tails of 2.5\% on either side
#' @param n number of equally spaced points to use on x-interval
#' @return dataframe with values for x (`x`), the mean value for y (`y`), and
#'   the lower and upper bounds of the confidence interval (`lower`, `upper`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 250)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_nls_fit(x, y)
#' df <- power_nls_predictioninterval(
#'   min(x), max(x), ft$multiplier, ft$power, ft$sd)
#'
#' plot(x, y, ylim = c(0, max(y)))
#' lines(df$x, df$mean, col = "red")
#' lines(df$x, df$lower, col = "blue")
#' lines(df$x, df$upper, col = "blue")
#'
power_nls_predictioninterval <- function(
    xmin,
    xmax,
    multiplier,
    power,
    sd,
    confidence = 0.95,
    n = 101
) {
  # generate or x-values range
  df <- data.frame(x = seq(xmin, xmax, l = n))
  # generate fit
  df$mean <- multiplier*df$x^power
  # distance
  m <- stats::qnorm(0.5 + 0.5*confidence, mean = 0, sd = sd)
  # lower and upper prediction interval
  df$lower <- df$mean - m
  df$upper <- df$mean + m
  # return dataframe
  df
}


power_nls_fit_gradientdescent <- function(
    x,
    y,
    weights = rep(1, length(x))
) {
  # initial guess for power-law - from log-log linear fit
  ft <- lm(log(y) ~ log(x), weights = weights)
  power0 <- as.numeric(coef(ft)[2])
  # find power, using gradient descent root solving techniques
  power <- rootSolve::multiroot(
    function(b, x, y, weights) {
      sum(weights*x^(2*b))*sum(weights*y*x^b*log(x)) -
        sum(weights*y*x^b)*sum(weights*x^(2*b)*log(x))
    },
    start = power0,
    jacfunc = function(b, x, y, weights) {
      sum(weights*x^(2*b)*log(x))*sum(weights*y*x^b*log(x)) +
        sum(weights*x^(2*b))*sum(weights*y*x^b*log(x)^2) -
        2*sum(weights*y*x^b)*sum(weights*x^(2*b)*log(x)^2)
    },
    x = x, y = y, weights = weights
  )$root
  # get multiplier
  multiplier <- sum(weights*y*x^power)/sum(weights*x^(2*power))
  # get standard deviation
  mu <- multiplier*x^power
  sd <- sqrt(sum(weights*(y - mu)^2)/sum(weights))
  # likelihood
  logp <- -log(sd) - 0.5*log(2*pi) - 0.5*((y - mu)/sd)^2
  # return dataframe
  data.frame(
    loglikelihood = sum(weights*logp),
    multiplier = multiplier,
    power = power,
    sd = sd
  )
}



#' @examples
#' beta <- 0.6
#' delta <- -2
#' x <- seq(2, 10, l = 1000)
#' y <- abs(100*x^beta + 50*rnorm(length(x))*x^delta)
#' y <- abs(y)
#' ft <- power_nls_variablesd_fit(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#' range <- 2*ft$sd_multiplier*xp^ft$sd_power
#'
#' plot(x, y)
#' lines(xp, yp, col = "red")
#' lines(xp, yp - range, col = "red")
#' lines(xp, yp + range, col = "red")
power_nls_variablesd_fit <- function(
    x,
    y,
    weights = rep(1, length(x))
) {
  # beta, from intial linear fit
  ft1 <- lm(log(y) ~ log(x), weights = weights)
  alpha <- exp(as.numeric(ft1$coefficients[1]))
  beta0 <- as.numeric(ft1$coefficients[2])
  # fit linear line though residuals
  res <- y - alpha*x^beta
  delta0 <- uniroot(
    function(d) -sum(weights*log(x)) + sum(weights)*sum(weights*res^2*x^(-2*d)*log(x))/sum(weights*res^2*x^(-2*d)),
    beta0 + c(-1, 1),
    extendInt = "downX"
  )$root
  #ft2 <- lm(log(res^2) ~ log(x), weights = weights)
  #delta0 <- as.numeric(ft2$coefficients[2])
  # fit
  sol <- rootSolve::multiroot(
    power_nls_variablesd_rootpowers,
    start = c(beta0, delta0),
    jacfunc = power_nls_variablesd_rootpowers_jacobian,
    x = x,
    y = y,
    weights = weights
  )
  # calculate coefficients
  co <- coef(sol$root[1], sol$root[2], x, y, weights = weights)
  multiplier <- co[5]/co[7]
  power <- sol$root[1]
  sd_multiplier <- sqrt((co[3]*co[7] - co[5]^2)/(co[1]*co[7]))
  sd_power = sol$root[2]
  # calculate likelihood
  mu <- multiplier*x^power
  sigma <- sd_multiplier*x^sd_power
  logpi <- -log(sigma) - 0.5*log(2*pi) - 0.5*((y - mu)/sigma)^2
  # dataframe with results
  data.frame(
    loglikelihood = sum(weights*logpi),
    multiplier = multiplier,
    power = sol$root[1],
    sd_multiplier = sd_multiplier,
    sd_power = sol$root[2]
  )
}


##
power_nls_variablesd_coef <- function(beta, delta, x, y, weights = rep(1, length(x))) {
  c(
    sum(weights),
    sum(weights*log(x)),
    sum(weights*y^2*x^(-2*delta)),
    sum(weights*y^2*x^(-2*delta)*log(x)),
    sum(weights*y*x^(beta - 2*delta)),
    sum(weights*y*x^(beta - 2*delta)*log(x)),
    sum(weights*x^(2*beta - 2*delta)),
    sum(weights*x^(2*beta - 2*delta)*log(x))
  )
}

#' @examples
#' beta <- -0.6
#' delta <- 0.2
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-beta * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' w <- runif(length(x))
#'
#' eps <- 1e-6
#' co <- power_nls_variablesd_coef(beta, delta, x, y, weights = w)
#' co1 <- power_nls_variablesd_coef(beta + eps, delta, x, y, weights = w)
#' co2 <- power_nls_variablesd_coef(beta, delta + eps, x, y, weights = w)
#' (cbind(co1, co2) - co)/eps
#' power_nls_variablesd_coef_jacobian(beta, delta, x, y, weights = w)
power_nls_variablesd_coef_jacobian <- function(beta, delta, x, y, weights = rep(1, length(x))) {
  cbind(
    c(
      0,
      0,
      0,
      0,
      sum(weights*y*x^(beta - 2*delta)*log(x)),
      sum(weights*y*x^(beta - 2*delta)*log(x)^2),
      2*sum(weights*x^(2*beta - 2*delta)*log(x)),
      2*sum(weights*x^(2*beta - 2*delta)*log(x)^2)
    ),
    c(
      0,
      0,
      -2*sum(weights*y^2*x^(-2*delta)*log(x)),
      -2*sum(weights*y^2*x^(-2*delta)*log(x)^2),
      -2*sum(weights*y*x^(beta - 2*delta)*log(x)),
      -2*sum(weights*y*x^(beta - 2*delta)*log(x)^2),
      -2*sum(weights*x^(2*beta - 2*delta)*log(x)),
      -2*sum(weights*x^(2*beta - 2*delta)*log(x)^2)
    )
  )
}
power_nls_variablesd_rootpowers <- function(par, x, y, weights = rep(1, length(x))) {
  co <- coef(par[1], par[2], x, y, weights = weights)
  r1 <- co[5]/co[7] - co[6]/co[8]
  r2 <- (co[3]*co[7] - co[5]^2)/(co[1]*co[7]) - (co[4]*co[8] - co[6]^2)/(co[2]*co[8])
  c(r1, r2)
}

#' @examples
#' par <- c(-0.6, -0.35)
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-beta * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' w <- runif(length(x))
#'
#' eps <- 1e-6
#' bd <- power_nls_variablesd_rootpowers(par, x, y, weights = w)
#' bd1 <- power_nls_variablesd_rootpowers(par + c(eps, 0), x, y, weights = w)
#' bd2 <- power_nls_variablesd_rootpowers(par + c(0, eps), x, y, weights = w)
#' (cbind(bd1, bd2) - bd)/eps
#' power_nls_variablesd_rootpowers_jacobian(par, x, y, weights = w)
#'
power_nls_variablesd_rootpowers_jacobian <- function(par, x, y, weights = rep(1, length(x))) {
  # coefficients
  co <- coef(par[1], par[2], x, y, weights = weights)
  dco_dpar <- coef_jacobian(par[1], par[2], x, y, weights = weights)
  # derivatives of root with respect to coefficients
  dr_dco <- rbind(
    c(
      0,
      0,
      0,
      0,
      1/co[7],
      -1/co[8],
      -co[5]/co[7]^2,
      co[6]/co[8]^2
    ),
    c(
      -(co[3]*co[7] - co[5]^2)/(co[1]^2*co[7]),
      (co[4]*co[8] - co[6]^2)/(co[2]^2*co[8]),
      1/co[1],
      -1/co[2],
      -2*co[5]/(co[1]*co[7]),
      2*co[6]/(co[2]*co[8]),
      co[3]/(co[1]*co[7]) - (co[3]*co[7] - co[5]^2)/(co[1]*co[7]^2),
      -co[4]/(co[2]*co[8]) + (co[4]*co[8] - co[6]^2)/(co[2]*co[8]^2)
    )
  )
  # derivatives of roots withr respect to <par>
  dr_dco %*% dco_dpar
}


## OLD

#' @examples
#' beta <- -0.6
#' delta <- -0.6
#' x <- seq(2, 10, l = 1000)
#' y <- abs(100*x^beta + 2*rnorm(length(x))*x^delta)
#' ft <- power_nls_variablesd_fit(x, y)
#'
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#' range <- 2*ft$sd_multiplier*xp^ft$sd_power
#' range2 <- 2*ft$sd_multiplier*xp^delta
#'
#' plot(x, y)
#' lines(xp, yp, col = "red")
#' lines(xp, yp - range, col = "red")
#' lines(xp, yp + range, col = "red")
#' lines(xp, yp - range2, col = "blue")
#' lines(xp, yp + range2, col = "blue")
power_nls_variablesd_fit_old <- function(
    x,
    y,
    weights = rep(1, length(x))
) {
  # beta, from intial linear fit
  ft1 <- lm(log(y) ~ log(x), weights = weights)
  alpha <- exp(as.numeric(ft1$coefficients[1]))
  beta <- as.numeric(ft1$coefficients[2])
  # fit linear line though residuals
  res <- y - alpha*x^beta
  ft2 <- lm(log(abs(res)) ~ log(x), weights = weights)
  delta <- as.numeric(ft2$coefficients[2])
  # fit
  sol <- optim(
    c(beta, delta),
    power_nls_variablesd_loglik,
    gr = power_nls_variablesd_loglik_jacobian,
    method = "BFGS",
    control = list(fnscale = -1),
    x = x,
    y = y,
    weights = weights
  )
  a_gsq <- alpha_gammasq(sol$par[1], sol$par[2], x, y, weights = weights)
  data.frame(
    multiplier = a_gsq[1],
    power = sol$par[1],
    sd_multiplier = sqrt(a_gsq[2]),
    sd_power = sol$par[2]
  )
}
power_nls_variablesd_loglik <- function(
    par,
    x,
    y,
    weights = rep(1, length(x))
) {
  # split parameters
  beta <- par[1]
  delta <- par[2]
  # get alpha and gamma
  a_gsq <- alpha_gammasq(beta, delta, x, y, weights = weights)
  alpha <- a_gsq[1]
  gammasq <- a_gsq[2]
  # mean and standard deviation
  mu <- alpha*x^beta
  sigmasq <- gammasq*x^(2*delta)
  # individual log-likelihoods
  logpi <- -0.5*log(sigmasq) - 0.5*log(2*pi) - 0.5*(y - mu)^2/sigmasq
  # return weighted loglikelihood
  sum(weights*logpi)
}


#' @examples
#' par <- c(-0.45, -0.05)
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^par[1] * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#'
#' eps <- 1e-6
#' L <- power_nls_variablesd_loglik(par, x, y)
#' L1 <- power_nls_variablesd_loglik(par + c(eps, 0), x, y)
#' L2 <- power_nls_variablesd_loglik(par + c(0, eps), x, y)
#' (c(L1, L2) - L)/eps
#' power_nls_variablesd_loglik_jacobian(par, x, y)
power_nls_variablesd_loglik_jacobian <- function(
    par,
    x,
    y,
    weights = rep(1, length(x))
) {
  # split parameters
  beta <- par[1]
  delta <- par[2]
  # get alpha and gamma
  a_gsq <- alpha_gammasq(beta, delta, x, y, weights = weights)
  alpha <- a_gsq[1]
  gammasq <- a_gsq[2]
  a_gsq_J <- alpha_gammasq_jacobian(beta, delta, x, y, weights = weights)
  # mean and squared standard deviation
  mu <- alpha*x^beta
  sigmasq <- gammasq*x^(2*delta)
  dmu_dbeta <- a_gsq_J$beta[1]*x^beta + alpha*log(x)*x^beta
  dmu_ddelta <- a_gsq_J$delta[1]*x^beta
  dsigmasq_dbeta <- a_gsq_J$beta[2]*x^(2*delta)
  dsigmasq_ddelta <- a_gsq_J$delta[2]*x^(2*delta) + 2*gammasq*log(x)*x^(2*delta)
  # individual log-likelihoods
  # logpi <- -0.5*log(sigmasq) - 0.5*log(2*pi) - 0.5*(y - mu)^2/sigmasq
  dlogpi_dmu <- (y - mu)/sigmasq
  dlogpi_dsigmasq <- -0.5/sigmasq + 0.5*(y - mu)^2/(sigmasq^2)
  dlogpi_dbeta <- dlogpi_dmu*dmu_dbeta + dlogpi_dsigmasq*dsigmasq_dbeta
  dlogpi_ddelta <- dlogpi_dmu*dmu_ddelta + dlogpi_dsigmasq*dsigmasq_ddelta
  # return weighted loglikelihood
  c(sum(weights*dlogpi_dbeta), sum(weights*dlogpi_ddelta))
}


#' @examples
#' par <- c(-0.45, -0.05)
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^par[1] * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' beta <- par[1]
#' delta <- par[2]
#' alpha_gammasq(beta, delta, x, y)
alpha_gammasq <- function(beta, delta, x, y, weights = rep(1, length(x))) {
  swl <- sum(weights*log(x))
  swyxb2d <- sum(weights*y*x^(beta - 2*delta))
  swx2b2d <- sum(weights*x^(2*beta - 2*delta))
  swylxb2d <- sum(weights*y*log(x)*x^(beta - 2*delta))
  swlx2b2d <- sum(weights*log(x)*x^(2*beta - 2*delta))
  swy2lx2d <- sum(weights*y^2*log(x)*x^(-2*delta))
  alpha <- swyxb2d/swx2b2d
  gammasq <- (swy2lx2d - 2*alpha*swylxb2d + alpha^2*swlx2b2d)/(delta*swl)
  c(alpha, abs(gammasq))

  sw <- sum(weights)
  swy2x2d <- sum(weights*y^2*x^(-2*delta))
  sw + 1/gammasq*(swy2x2d - 2*alpha*swyxb2d + alpha^2*swx2b2d)

}

#' @examples
#' x <- seq(2, 10, l = 25)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' beta <- -0.65
#' delta <- -0.15
#'
#' eps <- 1e-6
#' ag <- alpha_gammasq(beta, delta, x, y)
#' ag1 <- alpha_gammasq(beta + eps, delta, x, y)
#' ag2 <- alpha_gammasq(beta, delta + eps, x, y)
#' (ag1 - ag)/eps
#' (ag2 - ag)/eps
#' alpha_gammasq_jacobian(beta, delta, x, y)
alpha_gammasq_jacobian <- function(beta, delta, x, y, weights = rep(1, length(x))) {
  sw <- sum(weights)
  swyxb2d <- sum(weights*y*x^(beta - 2*delta))
  swx2b2d <- sum(weights*x^(2*beta - 2*delta))
  swy2x2d <- sum(weights*y^2*x^(-2*delta))
  swylxb2d <- sum(weights*y*log(x)*x^(beta - 2*delta))
  swlx2b2d <- sum(weights*log(x)*x^(2*beta - 2*delta))
  swy2lx2d <- sum(weights*y^2*log(x)*x^(-2*delta))
  alpha <- swyxb2d/swx2b2d
  gammasq <- (swy2x2d - 2*alpha*swyxb2d + alpha^2*swx2b2d)/(delta*sw)
  dalpha_dbeta <- swylxb2d/swx2b2d - 2*swyxb2d*swlx2b2d/swx2b2d^2
  dalpha_ddelta <- -2*swylxb2d/swx2b2d + 2*swyxb2d*swlx2b2d/swx2b2d^2
  dgamamsq_dalpha <- (-2*swyxb2d + 2*alpha*swx2b2d)/(delta*sw)
  dgammasq_dbeta <- (-2*alpha*swylxb2d + 2*alpha^2*swlx2b2d)/(delta*sw)
  dgammasq_ddelta <- (-2*swy2lx2d + 4*alpha*swylxb2d - 2*alpha^2*swlx2b2d)/(delta*sw) -
    ((swy2x2d - 2*alpha*swyxb2d + alpha^2*swx2b2d))/(delta^2*sw)
  list(
    beta = c(dalpha_dbeta, (dgamamsq_dalpha*dalpha_dbeta + dgammasq_dbeta)*sign(gammasq)),
    delta = c(dalpha_ddelta, (dgamamsq_dalpha*dalpha_ddelta + dgammasq_ddelta)*sign(gammasq))
  )
}


if (FALSE) {
  microbenchmark::microbenchmark(
    a = power_nls_fit(x, y, weights = weights),
    b = power_nls_fit_nlm(x, y, weights = weights),
    c = power_nls_fit_gradientdescent(x, y, weights = weights)
  )
}
