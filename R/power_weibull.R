# Functions for power-law fitting using Weibull probabilities
# 07/08/2023 - G. J. Meijer


#' Fit power law + weibull using loglikelihood fitting
#'
#' @description
#' Fit a power law distribution plus a Weibull shape parameter to a series
#' of test data (x, y), using the log-likelihood method.
#'
#' The variation in the data, defined as the ratio (y/y_fit) where y_fit is
#' predicted using a power law fit, is assumed to be Weibull distribution
#' with a mean of 1 and a to be fitted shape parameter.'
#'
#' To find the best fitting parameters for the power law, the probability of
#' all measurements is maximised.
#'
#' Measurements may be weighted according to their x-values in the form:
#' probability_weigthed = probability_{x,y}^weights, where `weights` is the
#' vector with weighting for each measured point. Given
#' that most biomechanical test relatively few thick roots, but thick roots
#' have a large effect on the calculated reinforcement, I suggest weighting
#' by the cross-sectional area, `weights = x^2`.
#'
#'
#' Function uses the function `optim()` from the package `stats` to conduct
#' the optimalisation.
#'
#' Initial parameter guesses for the log-likelihood fitting are estimated
#' using simple linear fits on transformed values of the input. These extra
#' initial fitting procedures ensure the `optim()` does not return inaccurate
#' values because the intial parameter guesses are too far removed from the
#' solution.
#'
#' @param x measured x-values (e.g. root diameters). These values are assumed
#'   to be already normalised by a reference value to ensure a unitless
#'   parameter.
#' @param y measured y-values (e.g. root tensile strength)
#' @param weights weighting for each measurement. Default = 1, but a strong
#'   case can be made for weighting with `weights = x^2` because of the
#'   large effect of thick roots on root-reinforcement
#' @param guess initial guess for multiplier (log-transformed), power-law,
#'   and weibull shape parameter (log-transformed). If not defined, an initial
#'   guess is made using the function `power_weibull_initialguess()`
#' @return a list containing the fields
#'   * `loglikelihood`: the log-likelihood score of the fit
#'   * `multiplier`: fit power-law multiplier
#'   * `power`: fit power coefficient
#'   * `shape`: fit Weibull shape parameter
#' @export
#' @examples
#' # input parameters
#' x <- seq(1, 10, l = 101)
#' alpha <- 5
#' beta <- -0.4
#' kappa <- 4
#' y <- alpha*x^beta*rweibull(length(x), kappa, 1/gamma(1 + 1/kappa))
#'
#' # fit
#' ft <- power_weibull_fit(x, y)
#' ft
#'
#' # plot
#' xp <- seq(min(x), max(x), l = 101)
#' yp <- ft$multiplier*xp^ft$power
#' plot(x, y)
#' lines(xp, yp, col = "red")
#'
#' # compare likelihood scores
#' y2 <- ft$multiplier*x^ft$power
#' p <- dweibull(y/y2, shape = ft$shape, scale = 1/gamma(1 + 1/ft$shape))
#'
#' ft$loglikelihood
#' sum(log(p))
power_weibull_fit <- function(
    x,
    y,
    weights = rep(1, length(x)),
    guess = NULL
) {
  # do not use any observations with NA values in x and/or y
  i <- !(is.na(x) | is.na(y))
  x <- x[i]
  y <- y[i]
  # make guess if needed
  if (is.null(guess)) {
    guess <- power_weibull_initialguess(x, y)
  }
  # log-likelihood fit
  ft <- stats::optim(
    guess,
    power_weibull_loglikelihood,
    gr = power_weibull_loglikelihood_jacobian,
    method = "BFGS",
    lx = log(x), ly = log(y), weights = weights,
    control = list(fnscale = -1)
  )
  # return
  data.frame(
    loglikelihood = ft$value,
    multiplier = exp(ft$par[1])*gamma(1 + 1/exp(ft$par[3])),
    power = ft$par[2],
    shape = exp(ft$par[3])
  )
}


#' GGplot for power-law with Weibull fitting
#'
#' @description
#' Generate a plot, using ggplot, of a power-law fit using weibull
#' probabilities. Will also show the best fit and prediction intervals if
#' values are given as input.
#'
#' @importFrom rlang .data
#' @param dr measured x-values (typically, root diameter)
#' @param y measured y-values (e.g. root tensile strength)
#' @param multiplier power-law multiplier for best fit
#' @param power power-law power coefficient for best fit
#' @param shape Weibull shape parameter
#' @param confidence vector with prediction interval significance. For example
#'   `confidence = c(0.5, 0.95)` will show the areas that contain 50% and 95%
#'   of predicted measurements respectively.
#' @param annotations dataframe with labels to annotate, generated by function
#'   `create_annotations()`
#' @param xlab,ylab x and y-axis labels
#' @param xlim,ylim two-element vectors with min and max values for the x and
#'   y-axes. If axis limit can be freely chosen, specify the value of the min
#'   and/or max as `NA`. The function will try to find nice axis limits for all
#'   `NA` values using the function `round_range()`,
#' @param ticks maximum number of ticks on the axis. Used in function
#'   `round_range()`
#' @param n number of (equally spaced) points along the best power-law fit
#' @param dr0 reference diameter for power-law fits
#' @param settings list with default plot settings, as generated by the function
#'   `plot_settings`
#' @return ggplot object
#' @export
#' @examples
#' # input parameters
#' dr <- seq(2, 9.5, l = 50)
#' multiplier <- 10
#' power <- -0.3
#' shape <- 4
#'
#' # generate some y-data
#' y <- multiplier*dr^power*rweibull(length(dr), shape = shape, scale = 1/gamma(1 + 1/shape))
#'
#' # generate some labels
#' ann <- create_annotations(
#'   c(multiplier, power, shape),
#'   prefix = c("t[r*','*u*','*0]==", "beta[t]==", "kappa[t]=="),
#'   suffix = c("~'MPa'", "", ""),
#'   parse = TRUE
#' )
#'
#' # plot
#' power_weibull_plot(dr, y, multiplier, power, shape, annotations = ann)
#'
power_weibull_plot <- function(
    dr,
    y,
    multiplier = NULL,
    power = NULL,
    shape = NULL,
    confidence = c(0.5, 0.95),
    annotations = NULL,
    xlab = expression("Root diameter"~d[r]~"[mm]"),
    ylab = expression("Tensile strength"~t[r*","*u]~"[MPa]"),
    xlim = c(0, NA),
    ylim = c(0, NA),
    ticks = 7,
    n = 101,
    dr0 = 1,
    settings = plot_settings()
) {
  # determine axes
  xlims <- round_range(dr, lim = xlim, ticks = ticks)
  ylims <- round_range(y, lim = ylim, ticks = ticks)
  # initiate plot
  plt <- ggplot2::ggplot() +
    ggplot2::theme_bw() +
    ggplot2::xlab(xlab) +
    ggplot2::ylab(ylab)
  # generate fits
  if (!is.null(multiplier) & !is.null(power)) {
    # generate fit line
    df_fit <- data.frame(dr = seq(min(dr), max(dr), l = n))
    df_fit$y <- multiplier*(df_fit$dr/dr0)^power
    if (!is.null(shape) & length(confidence) >= 1) {
      # generate confidence intervals
      df_c <- data.frame(
        confidence = confidence,
        mlower = stats::qweibull(0.5 - 0.5*confidence, shape = shape, scale = 1/gamma(1 + 1/shape)),
        mupper = stats::qweibull(0.5 + 0.5*confidence, shape = shape, scale = 1/gamma(1 + 1/shape))
      )
      df_conf <- expand_grid_df(df_fit, df_c)
      df_conf$lower <- df_conf$y*df_conf$mlower
      df_conf$upper <- df_conf$y*df_conf$mupper
      # add to plot
      plt <- plt + ggplot2::geom_ribbon(
        data = df_conf,
        ggplot2::aes(x = .data$dr, ymin = .data$lower, ymax = .data$upper, group = as.factor(.data$confidence)),
        fill = settings$fill_fit,
        alpha = settings$alpha_fit/length(confidence),
      )
      # update ranges
      xlims <- round_range(dr, lim = xlim, ticks = ticks)
      ylims <- round_range(c(df_conf$lower, df_conf$upper, y), lim = ylim, ticks = ticks)
    }
  }
  # add points to plot
  plt <- plt + ggplot2::geom_point(
    data = data.frame(x = dr, y = y),
    ggplot2::aes(x = .data$x, y = .data$y),
    color = settings$color_meas,
    shape = settings$shape_meas,
    size = settings$size_meas
  )
  # add fit to plot
  if (!is.null(multiplier) & !is.null(power)) {
    plt <- plt + ggplot2::geom_line(
      data = df_fit,
      ggplot2::aes(x = .data$dr, y = .data$y),
      color = settings$color_fit,
      linetype = settings$linetype_fit,
      linewidth = settings$linewidth_fit
    )
  }
  # add labels to plot
  if (!is.null(annotations)) {
    annotations$xplot <- xlims$lim[1] + diff(xlims$lim)*annotations$x
    annotations$yplot <- ylims$lim[1] + diff(ylims$lim)*annotations$y
    plt <- plt + ggplot2::geom_text(
      data = annotations,
      ggplot2::aes(x = .data$xplot, y = .data$yplot, label = .data$label, hjust = .data$hjust, vjust = .data$vjust),
      parse = annotations$parse[1],
      color = settings$color_ann,
      size = settings$size_ann
    )
  }
  # set axis limits
  plt <- plt +
    ggplot2::scale_x_continuous(breaks = xlims$breaks) +
    ggplot2::scale_y_continuous(breaks = ylims$breaks) +
    ggplot2::coord_cartesian(xlim = xlims$lim, ylim = ylims$lim, expand = FALSE)
  # return plot
  plt
}


#' Likelihood function for power-law weibull loglikelihood fitting
#'
#' @description
#' Calculates the negative loglikelihood of the power-law + weibull shape
#' fit. Multiplier and weibull shape parameters are inputted as log-
#' transformed values to avoid issues with negative numbers.
#'
#' @param par fitting parameter vector: log(multiplier), power, log(shape).
#' @param lx,ly vectors with log-transformed x and y measurements
#' @param weights weighting for each measurement
#' @return log-likelihood score
#' @export
#'
power_weibull_loglikelihood <- function(
    par,
    lx,
    ly,
    weights = rep(1, length(lx))
){
  # split param
  la <- par[1]
  b <- par[2]
  lk <- par[3]
  # likelihood
  (lk*sum(weights) +
      -la*exp(lk)*sum(weights) +
      -b*exp(lk)*sum(weights*lx) -
      -(exp(lk) - 1)*sum(weights*ly) +
      -exp(-la*exp(lk))*sum(weights*exp(exp(lk)*(ly - b*lx))))
}


#' Derivative of function `power_weibull_loglikelihood()`
#'
#' @description
#' Generates the derivative of the results of the function
#' `power_weibull_loglikelihood()` with respect to its input argument `par`.
#'
#' Function is vectorised.
#'
#' @inheritParams power_weibull_loglikelihood
#' @return vector with derivatives with respect to `par`
#' @export
#' @examples
#' # Compare analytical and numberical jacobians
#' x <- seq(1, 10, l = 51)
#' y <- 5*x^(0.5) + runif(length(x))
#' lx <- log(x)
#' ly <- log(y)
#' par <- c(log(3), -0.2, log(3.4))
#' weights <- x
#'
#' J <- power_weibull_loglikelihood_jacobian(
#'   par, lx, ly, weights = weights
#' )
#'
#' eps <- 1e-6
#' L <- power_weibull_loglikelihood(
#'   par, lx, ly, weights = weights
#' )
#' J2 <- rep(NA, 3)
#' for (i in 1:3) {
#'   dx <- rep(0, 3)
#'   dx[i] <- dx[i] + eps
#'   J2[i] <- (power_weibull_loglikelihood(
#'     par + dx, lx, ly, weights = weights) - L)/eps
#' }
#'
#' J
#' J2
#'
power_weibull_loglikelihood_jacobian <- function(
    par,
    lx,
    ly,
    weights = rep(1, length(lx))
) {
  # split param
  la <- par[1]
  b <- par[2]
  lk <- par[3]
  # derivatives
  dL_dla <- (
    -exp(lk)*sum(weights) +
    exp(lk - la*exp(lk))*sum(weights*exp(exp(lk)*(ly - b*lx)))
  )
  dL_db <- (
    -exp(lk)*sum(weights*lx) +
    exp(-la*exp(lk))*sum(weights*lx*exp(exp(lk)*(ly - b*lx) + lk))
  )
  dL_dlk <- (
    sum(weights) +
    -la*exp(lk)*sum(weights) +
    -b*exp(lk)*sum(weights*lx) +
    exp(lk)*sum(weights*ly) +
    la*exp(lk - la*exp(lk))*sum(weights*exp(exp(lk)*(ly - b*lx))) +
    -exp(-la*exp(lk))*sum(weights*(ly - b*lx)*exp(exp(lk)*(ly - b*lx) + lk))
  )
  # return
  c(dL_dla, dL_db, dL_dlk)
}


#' Create initial guess for weibull probability power-law fit
#'
#' @md
#' @description
#' Generate an initial guess for the power-law fit using weibull distributions
#' and loglikelihood fitting.
#'
#' The function makes a crude guess for the initial guess used in the function
#' `power_weibull()`, which consists of three numbers:
#'
#' * `log(alpha/gamma(1 + 1/kappa)) = log(alpha) - log(gamma(1 + 1/kappa))`
#' * `beta`
#' * `log(kappa)`
#'
#' where `alpha` and `beta` are the multiplier and power-law coefficient of
#' the best power-law fit, and `kappa` the shape parameter of the Weibull
#' distribution.
#' @param x,y arrays with measured values
#' @return vector with three elements, see Description
#' @export
#' @examples
#' # input data
#' nr <- 51
#' dr <- seq(1, 10, l = nr)
#' kappa <- 10000
#' alpha <- 10
#' beta <- -0.2
#' tru <- alpha*dr^beta * rweibull(nr, kappa, 1/gamma(1 + 1/kappa))
#'
#' # initial guess
#' par <- power_weibull_initialguess(dr, tru)
#' # predict
#' xf <- seq(min(dr), max(dr), l = 251)
#' yf <- exp(par[1])*gamma(1 + 1/exp(par[3]))*xf^par[2]
#'
#' # plot fit
#' plot(dr, tru)
#' lines(xf, yf, col = "red")
#'
power_weibull_initialguess <- function(x, y) {
  # linear fit through log-transformed x, y data to obtain a and b for power-law fit
  ft1 <- stats::lm(log(y) ~ log(x))
  la <- ft1$coef[1]
  b <- ft1$coef[2]
  # get weibull shape parameter - crude guess using linear fitting on
  # log-transformed cumulative probability curve
  t <- y/exp(stats::predict(ft1))
  c <- seq(0.01, 0.99, l = length(t))
  ft2 <- stats::lm(log(-log(1 - c)) ~ log(sort(t)))
  k <- ft2$coef[2]
  # return
  as.vector(c(la - log(gamma(1 + 1/k)), b, log(k)))
}


#' Generate prediction interval for log-transformed power-law fit
#'
#' @description
#' Generate a prediction interval with a certain amount of confidence it
#' contains a random new observation. Fit is generated by the function
#' `power_logtransform_fit()`.
#'
#' @inheritParams power_nls_predictioninterval
#' @param shape Weibull scale parameter
#' @param scale Weibull scale parameter
#' @return dataframe with values for x (`x`), the mean value for y (`y`), and
#'   the lower and upper bounds of the confidence interval (`lower`, `upper`)
#' @export
#' @examples
#' x <- seq(2, 10, l = 250)
#' y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
#' ft <- power_weibull_fit(x, y)
#' df <- power_weibull_predictioninterval(
#'   min(x), max(x), ft$multiplier, ft$power, ft$shape)
#'
#' plot(x, y, ylim = c(0, max(y)))
#' lines(df$x, df$mean, col = "red")
#' lines(df$x, df$lower, col = "blue")
#' lines(df$x, df$upper, col = "blue")
#'
power_weibull_predictioninterval <- function(
    xmin,
    xmax,
    multiplier,
    power,
    shape,
    scale = 1/gamma(1 + 1/shape),
    confidence = 0.95,
    n = 101
) {
  # generate or x-values range
  df <- data.frame(x = seq(xmin, xmax, l = n))
  # generate fit
  df$mean <- multiplier*df$x^power
  # distance - log-transformed space
  m <- stats::qweibull(
    0.5 + 0.5*c(-1, 1)*confidence,
    shape = shape,
    scale = scale
  )
  # lower and upper prediction interval
  df$lower <- m[1]*df$mean
  df$upper <- m[2]*df$mean
  # return dataframe
  df
}


#' Log-tranformed Weibull probability with power-law scale parameter
#'
#' @description
#' Calculate the log-transformed Weibull probability, where the scale parameter
#' of the distribution follows a power-law curve with `x` in the shape
#'
#'   y = alpha*x^power.
#'
#' The alpha parameter is related to the multiplier of the best power-law
#' fit through the mean of the Weibull distribution, i.e.
#'
#'   alpha = gamma(1 + 1/shape)*multiplier
#'
#' @inheritParams power_weibull_fit
#' @param alpha vector with alpha-values
#' @param power vector with power-law power coefficients
#' @param shape vector with Weibull shape parameters
#' @return vector with log-transformed probabilities for each x,y observation
#' @export
#' @examples
#' multiplier <- 10
#' power <- -0.5
#' shape <- 4
#' alpha <- multiplier/gamma(1 + 1/shape)
#' x <- seq(2, 8, l = 6)
#' y <- multiplier*x^power*rweibull(length(x), shape = shape, scale = 1/gamma(1 + 1/shape))
#' logp <- power_weibull_logdensity(x, y, alpha, power, shape)
#'
#' p <- pweibull(y/(multiplier*x^power), shape = shape, scale = 1/gamma(1 + 1/shape))
#'
#' exp(log(p))
#' p
#'
power_weibull_logdensity <- function(x, y, alpha, power, shape) {
  log(shape) +
    -shape*log(alpha) +
    -shape*power*log(x) +
    (shape - 1)*log(y) +
    -(y/(alpha*x^power))^shape
}


#' Derivative of function `power_weibull_logdensity()`
#'
#' @description
#' Generates the derivative of the results of the function
#' `power_weibull_logdensity()` with respect to its input arguments `alpha`,
#' `power` and `shape`
#'
#' Function is vectorised.
#'
#' @inheritParams power_weibull_logdensity
#' @return list with fields `alpha`, `power` and `shape`, containing jacobian
#'   matrices for these input arguments
#' @export
#' @examples
#' multiplier <- 9.2
#' power <- -0.41
#' shape <- 4.2
#' alpha <- multiplier/gamma(1 + 1/shape)
#' x <- seq(2, 8, l = 6)
#' y <- multiplier*x^power*rweibull(length(x), shape = shape, scale = 1/gamma(1 + 1/shape))
#'
#' p <- power_weibull_logdensity(x, y, alpha, power, shape)
#' J <- power_weibull_logdensity_jacobian(x, y, alpha, power, shape)
#'
#' eps <- 1e-6
#' Jalpha <- (power_weibull_logdensity(x, y, alpha + eps, power, shape) - p)/eps
#' Jpower <- (power_weibull_logdensity(x, y, alpha, power + eps, shape) - p)/eps
#' Jshape <- (power_weibull_logdensity(x, y, alpha, power, shape + eps) - p)/eps
#'
#' J
#' Jalpha
#' Jpower
#' Jshape
power_weibull_logdensity_jacobian <- function(x, y, alpha, power, shape) {
  list(
    alpha = -shape/alpha +
      shape/alpha*(y/(alpha*x^power))^shape,
    power = -shape*log(x) +
      shape*log(x)*(y/(alpha*x^power))^shape,
    shape = 1/shape +
      -log(alpha) +
      -power*log(x) +
      log(y) +
      -log(y/(alpha*x^power))*(y/(alpha*x^power))^shape
  )
}


power_weibull_loglikelihood2 <- function(
    par,
    x,
    y,
    weights = rep(1, length(x))
) {
  p <- power_weibull_logdensity(x, y, par[1], par[2], par[3])
  sum(weights*p)
}

power_weibull_loglikelihood2_jacobian <- function(
    par,
    x,
    y,
    weights = rep(1, length(x))
) {
  J <- power_weibull_logdensity_jacobian(x, y, par[1], par[2], par[3])
  c(
    sum(weights*J$alpha),
    sum(weights*J$power),
    sum(weights*J$shape)
  )
}

