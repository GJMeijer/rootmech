% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_nls.R
\name{power_normal_sdpower_fit}
\alias{power_normal_sdpower_fit}
\title{Fit power-law curve with normal residuals and power-law standard deviation}
\usage{
power_normal_sdpower_fit(x, y, weights = rep(1, length(x)))
}
\arguments{
\item{x}{measured x-values (e.g. root diameters). These values are assumed
to be already normalised by a reference value to ensure a unitless
parameter.}

\item{y}{measured y-values (e.g. root tensile strength)}

\item{weights}{weighting for each measurement. Default = 1, but a strong
case can be made for weighting with `weights = x^2` because of the
large effect of thick roots on root-reinforcement}
}
\value{
dataframe with the multiplier (`multiplier`) and power coefficient
  (`power`) of the fit, the multiplier (`sd_multiplier`) and
  power coefficient (`sd_power`) of the standard deviation of the residuals, the standard deviation of the residuals (`sd`) and the
  and the (weighted) loglikelihood score (`loglikelihood`)
}
\description{
Fit a power-law curve to a set of `x`, `y` data. The residuals are assumed
to be normally distributed with a mean of zero and a standard deviation that
itself varies with `x` according to a seperate power-law.

The problem is solved by maximising the loglikelihood score. In detail, the
problem is solved by root solving the derivatives of the loglikelihood
function. This results in only having to solve for two parameters
(power coeficient of fit, and that one of the standard deviation). The other
parameters can be expressed in terms of these two power coefficients.

The root problem is solved using the `rootSolve::multiroot()` function, with
a explicitly defined jacobian.
}
\examples{
beta <- -0.6
delta <- -0.4
x <- seq(2, 10, l = 100)
y <- abs(50*x^beta + 20*rnorm(length(x))*x^delta)
y <- abs(y)
ft <- power_normal_sdpower_fit(x, y)

xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power
range <- 2*ft$sd_multiplier*xp^ft$sd_power

plot(x, y)
lines(xp, yp, col = "red")
lines(xp, yp - range, col = "red")
lines(xp, yp + range, col = "red")
}
