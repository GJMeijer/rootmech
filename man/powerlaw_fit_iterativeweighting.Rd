% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powerlaw.R
\name{powerlaw_fit_iterativeweighting}
\alias{powerlaw_fit_iterativeweighting}
\title{Fit a power-law curve to a series of (x, y) data - iterative weighting}
\usage{
powerlaw_fit_iterativeweighting(
  x,
  y,
  model = "normal",
  weights = rep(1, length(x)),
  method = "bisection",
  range = c(-1, 1),
  frac = 0.5,
  n_max = 100,
  dn = 1
)
}
\arguments{
\item{x}{measured x-values (e.g. root diameters). These values are assumed
to be already normalised by a reference value to ensure a dimensionless
parameter.}

\item{y}{measured y-values (e.g. root tensile strength)}

\item{model}{model used to describe intra-diameter variation. Can be
one of the following:
\itemize{
\item \code{normal_strength}: normal distribution - constant standard deviation
with x (homoscedastic)
\item \code{normal_force}: normal distribution - constant standard deviation with
x in terms of forces (y*(pi/4*x^2))
\item \code{normal_scaled}: normal distribution - standard deviation scales with
mean
\item \code{normal_sdpower}: normal distribution - separate power-law describing the
mean and standard deviation
\item \code{lognormal}: lognormal distribution of ratio y/mean
\item \code{lognormal_uncorrected}: lognormal distribution with no means correction
(i.e. result of linear fitting on log-transformed data)
\item \code{weibull}: Weibull distribution; mean = power-law, constant shape
parameter
\item \code{gamma}: gamma distribution; mean = power law, constant shape parameter
\item \code{logistic}: logistic distribution; mean = power-law, scale parameter
scales with mean
\item \code{uniform}: uniform distribution; mean = power-law. width of uniform
distribution scales with mean
\item \code{gumbel}: Gumbel distribution; mean = power law, scale parameter
scales with mean
}}

\item{weights}{vector with weighting for each observation (default: 1)}

\item{method}{solving method. Can be \code{newton} for gradient-descent (using
\code{rootSolve::multiroot()}), \code{bisection} for a bisection algorithm
(using \code{stats::uniroot()}) or \code{chull} for a method involving convex
hulls (using, \code{grDevices::chull()}, only available for
\code{model == "uniform"})). Not all methods are available for each model,
see individual documentation for fitting functions for each model}

\item{range}{initial search range around best guess, when using a
bisection algorithm (\verb{method == "bisection}). \code{range} is added to the
best guess to provide the bounds of the initial search window}

\item{frac}{the weight scaling factor, see description}

\item{n_max}{maximum number of iterations per loop. If exceeded, the
function does not return anything}

\item{dn}{increment in n, see description}
}
\value{
same output as \code{powerlaw_fit()}. Returns \code{NULL} if too many
iterations are required
}
\description{
Fit a power-law curve to a series of weighted (x, y) data. Can use
different assumptions for the description of intra-diameter variation.

This function is a wrapper around the function \code{powerlaw_fit()}, designed
to deal with cases where there is very unequal weighting between various
observations. This may cause the initial guess, as used in a
gradient-descent root solving method, to be too far of the target, which
will inhibit convergence and may cause the algorithm to break.

This function gradually finds the solution by scaling the weighting factors,
and using the results from a fit to inform the 'next' fit with altered
weighting factors.

There are two loops:
\itemize{
\item in loop 1, the weighting is gradually reduced:

w = w^(frac^n)

where \code{frac} is a user-defined scaling fraction, and 'n' a counter which
increases with every iteration by a factor 'dn'
\item loop 2 starts once a stable solution is found in loop 1. The factor 'n'
is now reduced by 'dn' every step. The results from the previous analysis
are used as an initial guess for the next. If no stable solution is
found, dn is halved and a new guess is made. This process is continued
until n has reduced to 0 again and a stable solution is obtained
}
}
\examples{
y0 <- 20
beta <- -0.5
shape <- 4
x <- seq(1, 10, l = 51)
y <- y0*x^beta*stats::rweibull(length(x), shape, 1/gamma(1 + 1/shape))
y[x <= 3] <- 10*y[x <= 3]
weights <- x^2

model <- "logistic"
ft1 <- powerlaw_fit_iterativeweighting(x, y, model, weights = weights)

xp <- seq(min(x), max(x), l = 101)
yp <- ft1$multiplier*xp^ft1$exponent
plot(x, y)
lines(xp, yp, col = "red")

}
