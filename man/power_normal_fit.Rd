% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_nls.R
\name{power_normal_fit}
\alias{power_normal_fit}
\title{Fit power-law function assuming normally distributed residuals}
\usage{
power_normal_fit(
  x,
  y,
  weights = rep(1, length(x)),
  power_range = c(-2, 1),
  method = "uniroot",
  sd_power = 0
)
}
\arguments{
\item{x}{measured x-values (e.g. root diameters). These values are assumed
to be already normalised by a reference value to ensure a unitless
parameter.}

\item{y}{measured y-values (e.g. root tensile strength)}

\item{weights}{weighting for each measurement. Default = 1, but a strong
case can be made for weighting with `weights = x^2` because of the
large effect of thick roots on root-reinforcement}

\item{power_range}{default range in which the power coefficient is expected
to lie. This range is used in the `uniroot` root search algorithm. If the
value does not lie in this interval, it will be automatically extended in
the `uniroot()` function.}
}
\value{
dataframe with the multiplier (`multiplier`) and power coefficient
  (`power`), the standard deviation of the residuals (`sd`) and the
  loglikelihood score (`loglikelihood`)
}
\description{
Fit a power law function between `x` and `y` in the form y = a*x^b.

The fit is generated by depending on the choice of `method`. Either, the
log-likelihood probem is solved using a bracketing root finding algorithm
(`method = "uniroot"`) or gradient-descent root finding algorithm
(`method = "newton"`). If `method == "nls"`, the default R function
`stats::nls()` is used.
}
\examples{
x <- seq(2, 10, l = 25)
y <- 10*x^-0.5 * rweibull(length(x), shape = 4, scale = 1/gamma(1 + 1/4))
ft <- power_normal_fit(x, y)

xp <- seq(min(x), max(x), l = 101)
yp <- ft$multiplier*xp^ft$power

plot(x, y)
lines(xp, yp, col = "red")

}
