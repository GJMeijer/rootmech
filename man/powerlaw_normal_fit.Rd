% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powerlaw_normal.R
\name{powerlaw_normal_fit}
\alias{powerlaw_normal_fit}
\title{Power-law fit with normally distributed residuals}
\usage{
powerlaw_normal_fit(
  x,
  y,
  weights = rep(1, length(x)),
  method = "bisection",
  range = c(-1, 1),
  start = NULL,
  exponent = NULL,
  sd_exponent = 0,
  sd_exponent_range = c(-2, 2),
  n_range = 9
)
}
\arguments{
\item{x}{measured x-values (e.g. root diameters). These values are assumed
to be already normalised by a reference value to ensure a dimensionless
parameter.}

\item{y}{measured y-values (e.g. root tensile strength)}

\item{weights}{vector with weighting for each observation (default: 1)}

\item{method}{Only used when finding a single root.
Choose `newton` for gradient descent solving, using the
`rootSolve::multiroot()` function, or `bisection` for bisection root
solving algorithm using the `stats::uniroot()` function.
When using a multivariate root, `rootSolve::multiroot()` will always be
used.}

\item{range}{two-value array to add to best guess, to define initial
interval for bisection algorithm}

\item{start}{initial guess for power-log exponent. If not defined, an
initial guess is made using linear regression on log-transformed x and y
values}

\item{exponent}{will fix the value of the mean power-law exponent to a
specific numeric value, if defined. If defined as a character string,
beta = delta is assumed}

\item{sd_exponent}{will fix the value of the standard deviation power-law
exponent to a specific numeric value, if defined. If defined as a
character string, beta = delta is assumed}

\item{sd_exponent_range}{search range around beta, for initial guess of
delta in the case where both beta and delta are to be fitted. See function
`powerlaw_normal_freebetadelta_initialguess()` for more details.}

\item{n_range}{number of guesses for delta to be tried on range
`sd_exponent_range`. See function
`powerlaw_normal_freebetadelta_initialguess()` for more details.}
}
\value{
a list containing the fields
  * `loglikelihood`: the log-likelihood score of the fit
  * `multiplier`: fitted power-law multiplier
  * `exponent`: fitted power coefficient
  * `sd_multiplier`: fitted standard deviation power-law multiplier
  * `sd_exponent`: fitted standard deviation power-law exponent
}
\description{
Power-law fit of (x, y) data. For each value of x, the mean
of y is described by

  mu = y0*x^beta

where y0 is the power law multiplier, and beta the power law exponent.

The standard deviations are normally distributed, where the standard
deviation scales with the mean, i.e.

  sigma = sigma0*x^delta

where sigma0 is the power-law multiplier for the standard deviation, and
delta the power-law exponent.

The optimal fitting parameters y0, beta, sigma0 and delta are found by
maximising the (weighted) loglikelihood.
}
\examples{
# parameters
y0 <- 20
beta <- -0.25
sigma0 <- 2.5
delta <- -1
x <- seq(1, 8, l = 101)
mu <- y0*x^beta
sigma <- sigma0*x^delta
y <- abs(stats::rnorm(length(x), mu, sigma))
weights <- stats::runif(length(x), 0.9, 1.1)

# fit
ft <- powerlaw_normal_fit(x, y, weights = weights)
ft <- powerlaw_normal_fit(x, y, weights = weights, sd_exponent = -2)
ft <- powerlaw_normal_fit(x, y, weights = weights, sd_exponent = NULL)
ft <- powerlaw_normal_fit(x, y, weights = weights, sd_exponent = "linked")
ft
xp <- seq(min(x), max(x), l = 251)
yp <- ft$multiplier*xp^ft$exponent

# plot data and best fit
plot(x, y)
lines(xp, yp, col = "red")

}
