% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powerlaw.R
\name{powerlaw_fit}
\alias{powerlaw_fit}
\title{Fit a power-law curve to a series of (x, y) data}
\usage{
powerlaw_fit(
  x,
  y,
  model = "normal",
  weights = rep(1, length(x)),
  method = "bisection",
  range = c(-1, 1),
  start = NULL
)
}
\arguments{
\item{x}{measured x-values (e.g. root diameters). These values are assumed
to be already normalised by a reference value to ensure a dimensionless
parameter.}

\item{y}{measured y-values (e.g. root tensile strength)}

\item{model}{model used to describe intra-diameter variation. Can be
one of the following:
\itemize{
\item \code{normal_strength}: normal distribution - constant standard deviation
with x (homoscedastic)
\item \code{normal_force}: normal distribution - constant standard deviation with
x in terms of forces (y*(pi/4*x^2))
\item \code{normal_scaled}: normal distribution - standard deviation scales with
mean
\item \code{normal_sdpower}: normal distribution - separate power-law describing the
mean and standard deviation
\item \code{lognormal}: lognormal distribution of ratio y/mean
\item \code{lognormal_uncorrected}: lognormal distribution with no means correction
(i.e. result of linear fitting on log-transformed data)
\item \code{weibull}: Weibull distribution; mean = power-law, constant shape
parameter
\item \code{gamma}: gamma distribution; mean = power law, constant shape parameter
\item \code{logistic}: logistic distribution; mean = power-law, scale parameter
scales with mean
\item \code{uniform}: uniform distribution; mean = power-law. width of uniform
distribution scales with mean
\item \code{gumbel}: Gumbel distribution; mean = power law, scale parameter
scales with mean
}}

\item{weights}{vector with weighting for each observation (default: 1)}

\item{method}{solving method. Can be
\itemize{
\item \code{newton} for gradient-descent (using
\code{rootSolve::multiroot()})
\item \code{bisection} for a bisection algorithm
(using \code{stats::uniroot()})
\item \code{chull} for a method involving convex
hulls (using, \code{grDevices::chull()}. This method is only available for
\code{model == "uniform"}.
}

Not all methods are available for each model,
see individual documentation for fitting functions for each model (e.g.
by typing \code{?powerlaw_fit_weibull} into the R console).}

\item{range}{initial search range around best guess, when using a
bisection algorithm (\verb{method == "bisection}). \code{range} is added to the
best guess to provide the bounds of the initial search window}

\item{start}{optional starting values for fitting. If not defined, a guess
is made}
}
\value{
list with fitting results. Will contain fields
\itemize{
\item \code{loglikelihood} fitted loglikelihood
\item \code{multiplier} fitted power-law multiplier
\item \code{exponent}: fitted power-law exponent
\item \code{sd_multiplier}: standard deviation power-law multiplier (for models
\code{normal_x}()
\item \code{sd_exponent}: standard deviation power-law exponent (for models
\code{normal_x})
\item \code{sdlog}: log-standard deviation (for model \code{lognormal})
\item \code{scale}: scale parameter (for models \code{logistic}, and \code{gumbel})
\item \code{shape}: shape parameter (for models \code{gamma} and \code{weibull})
\item \code{width}: width of uniform distribution, at x = 1 (for model \code{uniform})
\item \code{ks_distance}: Kolmogorov-Smirnov distance of best fit
}
}
\description{
Fit a power-law curve to a series of weighted (x, y) data. Can use
different assumptions for the description of intra-diameter variation
}
\examples{
# generate some data
y0 <- 20
beta <- -0.5
kappa <- 4
lambda <- 1/gamma(1 + 1/kappa)
x <- seq(1, 8, l = 51)
y <- y0*x^beta*rweibull(length(x), kappa, lambda)

powerlaw_fit(x, y, model = "gamma")
powerlaw_fit(x, y, model = "gumbel")
powerlaw_fit(x, y, model = "logistic")
powerlaw_fit(x, y, model = "lognormal")
powerlaw_fit(x, y, model = "normal_strength")
powerlaw_fit(x, y, model = "normal_force")
powerlaw_fit(x, y, model = "normal_scaled")
powerlaw_fit(x, y, model = "normal_sdpower")
powerlaw_fit(x, y, model = "uniform")
powerlaw_fit(x, y, model = "weibull")

}
